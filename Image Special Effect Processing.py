# -*- coding: utf-8 -*-
"""ISE Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17PLGvdSeu_XkGsa1MSuL2KKjdWKCL5pu

# Part 1
"""

# History Book Of All Places

from PIL import Image, ImageFont, ImageDraw
import matplotlib.pyplot as plt

# Load the images
temple_image_pil = Image.open("/content/All Image.jpg")
overlay_image_pil = Image.open("/content/Overlay 13.jpg").convert("RGBA")
overlay_width, overlay_height = overlay_image_pil.size

new_temple_width = overlay_width // 2
new_temple_height = overlay_height

# Resize the temple image to fit into the right side of the overlay
temple_image_pil = temple_image_pil.resize((new_temple_width, new_temple_height))

# Create a new image with the same size as the overlay image to combine everything
combined_image_pil = Image.new('RGBA', (overlay_width, overlay_height))

# Paste the temple image on the right side of the combined image
combined_image_pil.paste(temple_image_pil, (new_temple_width, 0))

# Add text to the left side
draw = ImageDraw.Draw(combined_image_pil)
font = ImageFont.load_default()

# Define the text and its position
text = "ONCE UPON A TIME...\nSeonamsa Temple\n nestled amidst the\n serene beauty of\n Korea's mountains\n stands as a testament\n to the rich Buddhist\n heritage and\n architectural grandeur\n that has been preserved\n through centuries. "
text_x = 60
text_y = 50

# Set text color
text_color = (60, 60, 60)

draw.text((text_x, text_y), text, font=font, fill=text_color)

opacity = 0.5
intermediate_overlay_image_pil = Image.new("RGBA", overlay_image_pil.size, (0, 0, 0, 0))
intermediate_overlay_image_pil = Image.blend(intermediate_overlay_image_pil, overlay_image_pil, opacity)
final_image = Image.alpha_composite(combined_image_pil, intermediate_overlay_image_pil).convert("RGB")

# Save the glitched effect image
save_path = 'All Image Overlay Effect Image.jpg'
final_image.save(save_path)

fig, axs = plt.subplots(1, 3, figsize=(20, 15))

# Display original temple image
axs[0].imshow(temple_image_pil)
axs[0].set_title('Original All Image')
axs[0].axis('off')

# Display original overlay image
axs[1].imshow(overlay_image_pil)
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Display the final combined image
axs[2].imshow(final_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

plt.show()

# History Book Of All Places (Sparkle gif) (Online source image)

import imageio.v2 as imageio
from PIL import Image

# Load the image
final_image_path = "/content/All Image Overlay Effect Image.jpg"
final_image = Image.open(final_image_path)
sparkle_image_path = "/content/For gif used 5.jpg"
sparkle_image = Image.open(sparkle_image_path)

# Parameters for the animation
num_frames = 40
sparkle_size = (100, 100)

# Define the start and end positions
start_y = final_image.height - sparkle_size[1]
end_y = 0

frames = []

# Create each frame with the sparkle moving from bottom to top
for i in range(num_frames):
    y_position = start_y - int((start_y - end_y) * (i / num_frames))
    frame_with_sparkle = final_image.copy()
    resized_sparkle = sparkle_image.resize(sparkle_size)
    frame_with_sparkle.paste(resized_sparkle, (final_image.width // 2 - sparkle_size[0] // 2, y_position), resized_sparkle)
    frames.append(frame_with_sparkle)

# Save the frames as a GIF that loops indefinitely
gif_path = "Sparkle.gif"
imageio.mimsave(gif_path, frames, format='GIF', loop=0, fps=10)

# #Sansa, Buddhist Mountain Monasteries in Korea

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Function darkening the image
def simulate_deeper_night(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    hsv[:, :, 2] = np.maximum(hsv[:, :, 2] * 0.1, 0)
    night_image = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
    return night_image

# Function apply color inversion effect to the image
def color_inversion_effect(image):
    inverted_image = cv2.bitwise_not(image)
    return inverted_image

# Load the images
image_paths = [
    '/content/Sansa, Buddhist Mountain Monasteries in Korea 1.jpg',
    '/content/Sansa, Buddhist Mountain Monasteries in Korea 2.jpg',
    '/content/Sansa, Buddhist Mountain Monasteries in Korea 3.jpg'
]

# Apply the night simulation
original_images = [cv2.imread(path) for path in image_paths]
deeper_night_images = [simulate_deeper_night(img) for img in original_images]

# Apply color inversion effect
inverted_images = [color_inversion_effect(img) for img in original_images]

# Save the night effect image 1
output_path = 'Night Effect Image 1.jpg'
cv2.imwrite(output_path, deeper_night_images[0])

# Display the original, deeper night, and inverted color images side by side
fig, axes = plt.subplots(nrows=3, ncols=3, figsize=(20, 10))

for i, (original, deeper_night, inverted) in enumerate(zip(original_images, deeper_night_images, inverted_images)):
    axes[i, 0].imshow(cv2.cvtColor(original, cv2.COLOR_BGR2RGB))
    axes[i, 0].set_title('Original Image')
    axes[i, 0].axis('off')

    axes[i, 1].imshow(cv2.cvtColor(inverted, cv2.COLOR_BGR2RGB))
    axes[i, 1].set_title('Inverted Color Effect Image')
    axes[i, 1].axis('off')

    axes[i, 2].imshow(cv2.cvtColor(deeper_night, cv2.COLOR_BGR2RGB))
    axes[i, 2].set_title('Night Effect Image')
    axes[i, 2].axis('off')


plt.tight_layout()
plt.show()

#Sansa, Buddhist Mountain Monasteries in Korea (Star blinking gif) (Self create)

import imageio.v2 as imageio
from PIL import Image, ImageDraw
import random

# Load the image
background_image_path = "/content/Night Effect Image 1.jpg"
background = Image.open(background_image_path)

# Parameters for animation
num_frames = 40
num_stars = 100
star_size = 3

frames = []

# Generate random positions for stars and blinking patterns
stars_info = [(random.randint(0, background.width - star_size),
               random.randint(0, background.height - star_size),
               random.randint(0, num_frames // 2))
              for _ in range(num_stars)]

# Function to draw stars
def draw_stars(draw, stars_info, current_frame):
    for (x, y, start_frame) in stars_info:
        if current_frame >= start_frame:
            blink_state = (current_frame - start_frame) % 2 == 0
            if blink_state:
                shape = [(x, y), (x + star_size, y + star_size)]
                draw.ellipse(shape, fill="white")

# Create each frame with stars blinking at different times
for current_frame in range(num_frames):
    frame_with_stars = background.copy()
    draw = ImageDraw.Draw(frame_with_stars)
    draw_stars(draw, stars_info, current_frame)
    frames.append(frame_with_stars)

# Save the frames as a GIF that loops
gif_path = "Star Blinking.gif"
imageio.mimsave(gif_path, frames, format='GIF', loop=0, fps=10)

#Monasteries of Haghpat and Sanahin

import numpy as np
import cv2
from matplotlib import pyplot as plt

# Load the images
image_paths = ['/content/Monasteries of Haghpat and Sanahin 1.jpg',
               '/content/Monasteries of Haghpat and Sanahin 2.jpg',
               '/content/Monasteries of Haghpat and Sanahin 3.jpg']
images = [cv2.imread(path) for path in image_paths]

# Apply Gaussian Blur
very_strong_blurred_images = [cv2.GaussianBlur(image, (51, 51), 0) for image in images]

# Define selective colorization
def selective_colorization_green(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    lower_green = np.array([40, 40, 40])
    upper_green = np.array([80, 255, 255])
    mask = cv2.inRange(hsv, lower_green, upper_green)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray_3_channel = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
    color_selective = np.where(mask[:,:,None] != 0, image, gray_3_channel)
    return color_selective

# Apply selective colorization
green_colorized_images = [selective_colorization_green(image) for image in images]

# Display the original, Gaussian blurred, and green selective colorization images side by side
fig, axes = plt.subplots(nrows=3, ncols=3, figsize=(20, 10))

for i, (original, blurred, green_colorized) in enumerate(zip(images, very_strong_blurred_images, green_colorized_images)):
    # Original images
    axes[i, 0].imshow(cv2.cvtColor(original, cv2.COLOR_BGR2RGB))
    axes[i, 0].set_title('Original Image')
    axes[i, 0].axis('off')

    # Very strongly blurred images
    axes[i, 1].imshow(cv2.cvtColor(blurred, cv2.COLOR_BGR2RGB))
    axes[i, 1].set_title('Gaussian Blurred Effect Image')
    axes[i, 1].axis('off')

    # Green selective colorization images
    axes[i, 2].imshow(cv2.cvtColor(green_colorized, cv2.COLOR_BGR2RGB))
    axes[i, 2].set_title('Green Selective Colorization Effect Image')
    axes[i, 2].axis('off')

plt.tight_layout()
plt.show()

#Memphis and its Necropolis

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Function overlay with level of transparency
def apply_transparent_overlay(background_img, overlay_img, alpha=0.5):
    overlay_resized = cv2.resize(overlay_img, (background_img.shape[1], background_img.shape[0]))
    return cv2.addWeighted(background_img, 1 - alpha, overlay_resized, alpha, 0)

# Function colored halftone effect
def halftone_color_effect(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    small = cv2.resize(gray, (gray.shape[1] // 8, gray.shape[0] // 8), interpolation=cv2.INTER_LINEAR)
    large = cv2.resize(small, (gray.shape[1], gray.shape[0]), interpolation=cv2.INTER_NEAREST)
    _, halftone = cv2.threshold(large, 128, 255, cv2.THRESH_BINARY)
    halftone_color = cv2.cvtColor(halftone, cv2.COLOR_GRAY2BGR)
    halftone_color = cv2.bitwise_and(image, halftone_color)
    return halftone_color

# Paths original and overlay images
original_paths = ['/content/Memphis and its Necropolis 1.jpg',
                  '/content/Memphis and its Necropolis 2.jpg',
                  '/content/Memphis and its Necropolis 3.jpg']
overlay_path = '/content/Overlay 14.jpg'

# Load the original and overlay images
originals = [cv2.imread(path) for path in original_paths]
overlay = cv2.imread(overlay_path)

overlay_effect_images = [apply_transparent_overlay(img, overlay, alpha=0.5) for img in originals]

colored_halftone_effect_images = [halftone_color_effect(img) for img in overlay_effect_images]

# Display the images
fig, axs = plt.subplots(3, 5, figsize=(20, 12))

for i in range(3):
    axs[i, 0].imshow(cv2.cvtColor(originals[i], cv2.COLOR_BGR2RGB))
    axs[i, 0].axis('off')
    axs[i, 0].set_title('Original Image')

    axs[i, 1].imshow(cv2.cvtColor(overlay, cv2.COLOR_BGR2RGB))
    axs[i, 1].axis('off')
    axs[i, 1].set_title('Overlay Image')

    axs[i, 2].imshow(cv2.cvtColor(overlay_effect_images[i], cv2.COLOR_BGR2RGB))
    axs[i, 2].axis('off')
    axs[i, 2].set_title('Overlay Effect')

    axs[i, 3].imshow(cv2.cvtColor(overlay_effect_images[i], cv2.COLOR_BGR2GRAY), cmap='gray')
    axs[i, 3].axis('off')
    axs[i, 3].set_title('B&W Halftone Effect')

    axs[i, 4].imshow(cv2.cvtColor(colored_halftone_effect_images[i], cv2.COLOR_BGR2RGB))
    axs[i, 4].axis('off')
    axs[i, 4].set_title('Colored Halftone Effect')

plt.tight_layout()
plt.show()

# Rapa Nui National Park

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Function grayscale effect
def grayscale_effect(image):
    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Function exposure effect
def black_white_exposure(image):
    _, bw_image = cv2.threshold(image, 128, 255, cv2.THRESH_BINARY)
    return bw_image

# Function summer effect
def summer_effect(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    h, s, v = cv2.split(hsv)
    s = cv2.add(s, 30)
    v = cv2.add(v, 30)
    return cv2.cvtColor(cv2.merge([h, s, v]), cv2.COLOR_HSV2BGR)

# Function spring effect
def spring_effect(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    h, s, v = cv2.split(hsv)
    s = cv2.add(s, 50)
    return cv2.cvtColor(cv2.merge([h, s, v]), cv2.COLOR_HSV2BGR)

# Function winter effect
def winter_effect(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    h, s, v = cv2.split(hsv)
    s = cv2.subtract(s, 50)
    v = cv2.subtract(v, 50)
    return cv2.cvtColor(cv2.merge([h, s, v]), cv2.COLOR_HSV2BGR)

# Function autumn effect
def autumn_effect(image):
    b, g, r = cv2.split(image)
    r = cv2.add(r, 30)
    b = cv2.subtract(b, 30)
    return cv2.merge([b, g, r])

# Load the original images
image_paths = [
    '/content/Rapa Nui National Park 1.jpg',
    '/content/Rapa Nui National Park 2.jpg',
    '/content/Rapa Nui National Park 3.jpg',
    '/content/Rapa Nui National Park 4.jpg'
]
original_images = [cv2.imread(path) for path in image_paths]

# Apply effects
grayscale_images = [grayscale_effect(img) for img in original_images]
bw_exposure_images = [black_white_exposure(grayscale_images[i]) for i in range(len(grayscale_images))]
summer_images = [summer_effect(img) for img in original_images]
spring_images = [spring_effect(img) for img in original_images]
winter_images = [winter_effect(img) for img in original_images]
autumn_images = [autumn_effect(img) for img in original_images]

# Set up the subplot for 7 columns and 4 rows
fig, axs = plt.subplots(4, 7, figsize=(24, 12))

# Titles for each effect
titles = ['Original', 'Grayscale', 'B&W Exposure', 'Summer', 'Spring', 'Autumn', 'Winter']

# Display all images with effects
for i in range(4):
    for j, images in enumerate([original_images, grayscale_images, bw_exposure_images, summer_images, spring_images, autumn_images, winter_images]):
        ax = axs[i, j]
        image = images[i]
        cmap = 'gray' if j == 1 or j == 2 else None
        ax.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB) if cmap is None else image, cmap=cmap)
        ax.axis('off')
        ax.set_title(f"{titles[j]} Effect Image")

plt.tight_layout()
plt.show()

#Archaeological Site of Cyrene

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Function to save the image
def save_image_cv2(img, file_path):
    # Convert from RGB to BGR
    img_bgr = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
    cv2.imwrite(file_path, img_bgr)

# Load the images
first_image_path = '/content/Archaeological Site of Cyrene 1.jpg'
second_image_path = '/content/Archaeological Site of Cyrene 2.jpg'

# Print second image path
print(f"Second Image Path: {second_image_path}")

first_image = cv2.imread(first_image_path)
second_image = cv2.imread(second_image_path)

# Convert from BGR to RGB
first_image = cv2.cvtColor(first_image, cv2.COLOR_BGR2RGB)
second_image = cv2.cvtColor(second_image, cv2.COLOR_BGR2RGB)

# Function darken image
def make_night_cv2(img, darkness_factor=0.1):
    img_float = img.astype(np.float64)
    darker_img = cv2.multiply(img_float, np.array([darkness_factor]))
    darker_img = np.clip(darker_img, 0, 255).astype(np.uint8)
    return darker_img

night_image = make_night_cv2(first_image)

# Save the night effect image of the first image
save_image_path = 'Night Effect on First Image.jpg'
save_image_cv2(night_image, save_image_path)

# Save the second image
save_image_path_2 = 'Original Image 2.jpg'
save_image_cv2(second_image, save_image_path_2)

# Display the images using matplotlib
plt.figure(figsize=(20, 10))

# Display the first original image
plt.subplot(1, 3, 1)
plt.imshow(first_image)
plt.title('First Original Image')
plt.axis('off')

# Display the second original image
plt.subplot(1, 3, 2)
plt.imshow(second_image)
plt.title('Second Original Image')
plt.axis('off')

# Display the night effect image of the first image
plt.subplot(1, 3, 3)
plt.imshow(night_image)
plt.title('Night Effect on First Image')
plt.axis('off')

# Show the plot
plt.show()

# Archaeological Site of Cyrene (Raining gif) (Selfcreate)

from PIL import Image, ImageDraw
import random

# Load the image
background_image_path = '/content/Night Effect on First Image.jpg'
background = Image.open(background_image_path)

# Parameters for the rain animation
num_frames = 30
rain_color = (173, 216, 230)

# Adjust the size of the rain animation
width, height = background.size

# Function frame with rain effect
def create_rain_frame(background, width, height, num_drops=100):
    frame = background.copy()
    draw = ImageDraw.Draw(frame)
    for _ in range(num_drops):
        x0 = random.randint(0, width)
        y0 = random.randint(0, height)
        x1 = x0 + random.randint(1, 3)
        y1 = y0 + random.randint(10, 15)
        draw.line([(x0, y0), (x1, y1)], fill=rain_color, width=1)
    return frame

rain_frames = [create_rain_frame(background, width, height) for _ in range(num_frames)]

# Save as an animated GIF
output_rain_gif_path = "Raining.gif"
rain_frames[0].save(output_rain_gif_path, save_all=True, append_images=rain_frames[1:], optimize=False, duration=50, loop=0)

#Archaeological Site of Cyrene (History text gif) (Self create)

from PIL import Image, ImageDraw, ImageFont

# Load the background image
background_image_path = '/content/Original Image 2.jpg'
background_image = Image.open(background_image_path)

# Text to be used in the GIF
text = ("A colony of the Greeks of Thera, Cyrene was one of the principal cities "
        "in the Hellenic world. It was Romanized and remained a great capital until "
        "the earthquake of 365. A thousand years of history is written into its ruins, "
        "which have been famous since the 18th century.")

# Set bold font
font_size = 50
try:
    font = ImageFont.truetype("LiberationSerif-Bold.ttf", font_size)  #
except IOError:
    font = ImageFont.load_default()

text_width, text_height = font.getsize(text)

# Calculate starting position to center the text horizontally and vertically
initial_x_position = background_image.width

# Calculate y position
y_position = (background_image.height - text_height) // 2

# Number of frames in the animation
num_frames = 200  # Adjust the number of frames for desired scrolling speed

# Create frames with the text animation
frames = []
for frame_number in range(num_frames):
    x_position = initial_x_position - (initial_x_position + text_width) * frame_number / num_frames
    frame = background_image.copy()
    draw = ImageDraw.Draw(frame)
    draw.text((x_position, y_position), text, font=font, fill="black")
    frames.append(frame)

# Save as an animated GIF
output_gif_with_background_path = "History Text.gif"
frames[0].save(output_gif_with_background_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

output_gif_with_background_path

# Melaka and George Town

from PIL import Image, ImageOps
import matplotlib.pyplot as plt
import numpy as np

# Importing the images
img1_path = '/content/Melaka and George Town 1.jpg'
img2_path = '/content/Melaka and George Town 2.jpg'
img3_path = '/content/Melaka and George Town 3.jpg'
overlay_path = '/content/Overlay 17.jpg'

# Load the images
img1 = Image.open(img1_path)
img2 = Image.open(img2_path)
img3 = Image.open(img3_path)
overlay_img = Image.open(overlay_path)

# Convert the overlay image to grayscale
overlay_newspaper = ImageOps.grayscale(overlay_img)
overlay_newspaper = ImageOps.colorize(overlay_newspaper, 'black', 'white')
overlay_newspaper = overlay_newspaper.convert('RGBA')

# Resize the overlay images
overlay_resized1 = overlay_newspaper.resize(img1.size)
overlay_resized2 = overlay_newspaper.resize(img2.size)
overlay_resized3 = overlay_newspaper.resize(img3.size)

# Function to apply overlay with 50% transparency
def apply_overlay_with_transparency(original, overlay, transparency=0.5):
    original_rgba = original.convert("RGBA")
    overlay_rgba = overlay.convert("RGBA")
    overlay_rgba.putalpha(int(255 * transparency))
    return Image.alpha_composite(original_rgba, overlay_rgba)

# Apply the overlay effect with 50% transparency
overlay_effect_img1 = apply_overlay_with_transparency(img1, overlay_resized1)
overlay_effect_img2 = apply_overlay_with_transparency(img2, overlay_resized2)
overlay_effect_img3 = apply_overlay_with_transparency(img3, overlay_resized3)

# Convert the overlay effect images to grayscale
overlay_effect_img1 = ImageOps.grayscale(overlay_effect_img1)
overlay_effect_img2 = ImageOps.grayscale(overlay_effect_img2)
overlay_effect_img3 = ImageOps.grayscale(overlay_effect_img3)

# Save the glitched effect image
save_path = 'Melaka and George Town Overlay Effect Image.jpg'  #
overlay_effect_img2.save(save_path)

# Create a figure with a 3x3 grid
fig, axs = plt.subplots(3, 3, figsize=(20, 12))

# Display original images
axs[0, 0].imshow(img1)
axs[0, 0].axis('off')
axs[0, 0].set_title('Original Image')

axs[1, 0].imshow(img2)
axs[1, 0].axis('off')
axs[1, 0].set_title('Original Image')

axs[2, 0].imshow(img3)
axs[2, 0].axis('off')
axs[2, 0].set_title('Original Image 3')

# Display overlay
axs[0, 1].imshow(overlay_newspaper, cmap='gray')
axs[0, 1].axis('off')
axs[0, 1].set_title('Overlay Image')

axs[1, 1].imshow(overlay_newspaper, cmap='gray')
axs[1, 1].axis('off')
axs[1, 1].set_title('Overlay Image')

axs[2, 1].imshow(overlay_newspaper, cmap='gray')
axs[2, 1].axis('off')
axs[2, 1].set_title('Overlay Image')

# Display images with 50% transparency overlay
axs[0, 2].imshow(overlay_effect_img1, cmap='gray')
axs[0, 2].axis('off')
axs[0, 2].set_title('Transparency Effect Image')

axs[1, 2].imshow(overlay_effect_img2, cmap='gray')
axs[1, 2].axis('off')
axs[1, 2].set_title('Transparency Effect Image')

axs[2, 2].imshow(overlay_effect_img3, cmap='gray')
axs[2, 2].axis('off')
axs[2, 2].set_title('Transparency Effect Image')

# Melaka and George Town (Birds flying gif) (Self create)

import numpy as np
import imageio.v2 as imageio
from PIL import Image, ImageDraw

# Load the image
background_image_path = "/content/Melaka and George Town Overlay Effect Image.jpg"
background = Image.open(background_image_path)

# Parameters for the animation
num_frames = 60
num_birds = 5

# Function to create a bird shape
def create_bird(x, y):
    bird = [(x, y), (x - 5, y + 2), (x, y), (x + 5, y + 2)]
    return bird

# Function to create a smooth trajectory for the birds
def create_trajectory(start, end, num_frames):
    x_positions = np.linspace(start[0], end[0], num_frames)
    y_mid = (start[1] + end[1]) / 2
    y_amplitude = (end[1] - start[1]) / 2
    y_positions = y_mid + y_amplitude * np.sin(np.linspace(0, np.pi, num_frames))
    return list(zip(x_positions, y_positions))

# Create birds movement
trajectories = []
for _ in range(num_birds):
    start_x = np.random.randint(0, background.width // 4)
    end_x = background.width - start_x
    start_y = np.random.randint(background.height // 4, background.height // 3)
    end_y = np.random.randint(background.height // 4, background.height // 3)
    trajectories.append(create_trajectory((start_x, start_y), (end_x, end_y), num_frames))

# Draw each frame
frames = []
for i in range(num_frames):
    frame = background.copy()
    draw = ImageDraw.Draw(frame)
    for traj in trajectories:
        bird = create_bird(*traj[i])
        draw.line(bird, fill="black", width=1)

    frames.append(frame)

# Save the frames as a GIF t
gif_path = "Birds Flying.gif"
imageio.mimsave(gif_path, frames, format='GIF', loop=0, fps=12)

# Paris, Banks of the Seine

import cv2
import numpy as np
from matplotlib import pyplot as plt

def apply_tilt_shift_effect(image_path):
    # Load the image
    image = cv2.imread(image_path)

    # Create a mask with a horizontal gradient
    mask = np.zeros(image.shape[:2], dtype=np.float32)
    rows, cols = mask.shape
    mask[int(rows*0.3):int(rows*0.7)] = 1
    mask = cv2.GaussianBlur(mask, (0, 0), cols/30)
    mask = cv2.merge([mask, mask, mask])

    # Create the blurred image
    blurred = cv2.GaussianBlur(image, (0, 0), cols/30)

    # Blend the focused and blurred images
    tilt_shift_img = image * mask + blurred * (1 - mask)

    # Convert to uint8
    tilt_shift_img = np.clip(tilt_shift_img, 0, 255).astype(np.uint8)

    return image, tilt_shift_img

def apply_corruption_effect(image):
    noise = np.random.normal(0, 25, image.shape).astype(np.uint8)
    corrupted_img = cv2.add(image, noise)

    return corrupted_img

# Paths to the images
image_paths = [
    '/content/Paris, Banks of the Seine 1.jpg',
    '/content/Paris, Banks of the Seine 2.jpg',
    '/content/Paris, Banks of the Seine 3.jpg'
]

# Process each image and display
for path in image_paths:
    original_img, tilt_shift_img = apply_tilt_shift_effect(path)
    corrupted_img = apply_corruption_effect(original_img)

    # Display the images
    plt.figure(figsize=(15, 5))

    # Original image
    plt.subplot(1, 3, 1)
    plt.imshow(cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    # Tilt-shift effect image
    plt.subplot(1, 3, 2)
    plt.imshow(cv2.cvtColor(tilt_shift_img, cv2.COLOR_BGR2RGB))
    plt.title('Tilt-Shift Effect Image')
    plt.axis('off')

    # Corrupted effect image
    plt.subplot(1, 3, 3)
    plt.imshow(cv2.cvtColor(corrupted_img, cv2.COLOR_BGR2RGB))
    plt.title('Corrupted Effect Image')
    plt.axis('off')

    plt.show()

"""# Part 2 Place 1"""

#Memphis and its Necropolis 1

from PIL import Image, ImageChops, ImageFilter
import numpy as np
import matplotlib.pyplot as plt

# Load the image
original_image_path = '/content/Memphis and its Necropolis 1.jpg'
overlay_image_path = '/content/Overlay 1.jpg'
original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Ensure the overlay image is the same size as the original image
overlay_image = overlay_image.resize(original_image.size)

# Apply contrast to an image
def apply_contrast(image, level):
    factor = (259 * (level + 255)) / (255 * (259 - level))
    def contrast(c):
        return 128 + factor * (c - 128)
    return image.point(contrast)

# Apply overlay effect
def apply_overlay(original, overlay):
    return ImageChops.multiply(original, overlay)

# Function to create a glitch effect on an image
def apply_glitch(image):
    image_rgb = image.convert('RGB')

    # Glitch effect parameters
    offset = 10
    interval = 5

    # Split the image into RGB channels
    channels = [np.array(c) for c in image_rgb.split()]

    # Apply glitch effect by offsetting channels
    for i in range(0, image_rgb.size[1], interval):
        for c in channels:
            c[i:i+interval] = np.roll(c[i:i+interval], np.random.randint(-offset, offset), axis=1)

    # Merge channels and convert to image
    np_image = np.dstack(channels)
    return Image.fromarray(np_image)

# Apply contrast to the original image
contrast_image = apply_contrast(original_image, level=100)

# Apply overlay effect
overlay_effect_image = apply_overlay(original_image, overlay_image)

# Apply glitch effect
glitch_effect_image = apply_glitch(overlay_effect_image)

# Save the glitched effect image
save_path = 'Memphis and its Necropolis 1 Glitched Effect Image.jpg'  # Specify your save path
glitch_effect_image.save(save_path)

# Display the images
fig, axs = plt.subplots(1, 5, figsize=(20, 5))

# Original Image
axs[0].imshow(np.array(original_image))
axs[0].set_title('Original Image')
axs[0].axis('off')

# Contrast Image
axs[1].imshow(np.array(contrast_image))
axs[1].set_title('Contrast Image')
axs[1].axis('off')

# Overlay Image
axs[2].imshow(np.array(overlay_image))
axs[2].set_title('Overlay Image')
axs[2].axis('off')

# Overlay Effect Image
axs[3].imshow(np.array(overlay_effect_image))
axs[3].set_title('Overlay Effect Image')
axs[3].axis('off')

# Glitched Effect Image
axs[4].imshow(np.array(glitch_effect_image))
axs[4].set_title('Glitched Effect Image')
axs[4].axis('off')

plt.tight_layout()
plt.show()

# Memphis and its Necropolis 1 (Sand storm gif) (Self create)

from PIL import Image
import numpy as np

def create_sandstorm_effect(bg_width, bg_height, density=0.5):
    sandstorm = Image.new('RGBA', (bg_width, bg_height))
    for x in range(bg_width):
        for y in range(bg_height):
            if np.random.rand() <= density:
                opacity = np.random.randint(50, 150)
                sandstorm.putpixel((x, y), (210, 180, 140, opacity))
    return sandstorm

def create_sandstorm_frames(background, num_frames=20, speed=5):
    bg_width, bg_height = background.size
    sandstorm_effect = create_sandstorm_effect(bg_width, bg_height)

    frames = []
    for i in range(num_frames):
        frame = background.copy()
        offset = (speed * i) % bg_width
        sandstorm_moving = Image.new('RGBA', (bg_width, bg_height))
        sandstorm_moving.paste(sandstorm_effect, (offset - bg_width, 0))
        sandstorm_moving.paste(sandstorm_effect, (offset, 0))

        frame.paste(sandstorm_moving, mask=sandstorm_moving)
        frames.append(frame)
    return frames

# Load the image
background = Image.open("Memphis and its Necropolis 1 Glitched Effect Image.jpg")

# Create sandstorm frames
frames = create_sandstorm_frames(background, num_frames=20, speed=20)

# Save the frames as a GIF
frames[0].save("Sandstorm.gif", save_all=True, append_images=frames[1:], optimize=False, duration=50, loop=0)

# Memphis and its Necropolis 2

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Function overlay images
def overlay_images(background, overlay, alpha=0.5):
    overlay_resized = cv2.resize(overlay, (background.shape[1], background.shape[0]))
    return cv2.addWeighted(background, 1 - alpha, overlay_resized, alpha, 0)

# Function shadow image
def add_shadow(image, offset=(5, 5), shadow_intensity=50):
    shadow = np.zeros_like(image)
    shadow[offset[1]:, offset[0]:] = image[:-offset[1], :-offset[0]].astype(np.int16) - shadow_intensity
    shadow = np.clip(shadow, 0, 255).astype(np.uint8)
    combined = np.where(shadow == 0, image, shadow)
    return combined

# Function Sobel filter
def apply_sobel_filter(image):
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    sobel_x = cv2.Sobel(gray_image, cv2.CV_64F, 1, 0, ksize=5)
    sobel_y = cv2.Sobel(gray_image, cv2.CV_64F, 0, 1, ksize=5)
    sobel = cv2.addWeighted(cv2.convertScaleAbs(sobel_x), 0.5, cv2.convertScaleAbs(sobel_y), 0.5, 0)
    return cv2.cvtColor(sobel, cv2.COLOR_GRAY2BGR)
# Function save image
def save_image(image, path):
    cv2.imwrite(path, image)

# Load the overlay image
overlay_image_path = '/content/Overlay 5.jpg'
overlay_image = cv2.imread(overlay_image_path)

# Paths to the background images
background_images_paths = [
    '/content/Memphis and its Necropolis 2.jpg',
]

# Process each background image
for i, background_path in enumerate(background_images_paths):
    background_image = cv2.imread(background_path)
    combined_image = overlay_images(background_image, overlay_image, alpha=0.5)
    shadow_image = add_shadow(combined_image)
    sobel_image = apply_sobel_filter(combined_image)
    plt.figure(figsize=(20, 10))
    titles = ['Original Image', 'Overlay Image', 'Overlay Effect Image', 'Shadow Effect Image ', 'Sobel Filter Effect Image']
    images = [background_image, overlay_image, combined_image, shadow_image, sobel_image]

    for j, image in enumerate(images, 1):
        plt.subplot(1, 5, j)
        plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        plt.title(titles[j-1])
        plt.axis('off')

    plt.tight_layout()
    plt.show()

    # Save the Shadow filter effect image from the first row
    if i == 0:
        save_image_path = 'Memphis and its Necropolis 2 Shadow Effect Image.jpg'  # Update this path
        save_image(shadow_image, save_image_path)

# Memphis and its Necropolis 2 (Moving spaceship gif) (Online source image)

from PIL import Image

# Load background images
background = Image.open("/content/Memphis and its Necropolis 2 Shadow Effect Image.jpg")
spaceship = Image.open("/content/For gif used 1.jpg")

# Determine the number of frames
number_of_frames_one_way = 10
bg_width, bg_height = background.size
sp_width, sp_height = spaceship.size
space_between = (bg_width - sp_width) // (number_of_frames_one_way - 1)

# Create the frames for the GIF
frames = []

# Move from left to right
for i in range(number_of_frames_one_way):
    temp_bg = background.copy()
    position = (i * space_between, bg_height // 2 - sp_height // 2)
    temp_bg.paste(spaceship, position, spaceship)
    frames.append(temp_bg)

# Move from right to left
for i in range(number_of_frames_one_way - 2, -1, -1):
    temp_bg = background.copy()
    position = (i * space_between, bg_height // 2 - sp_height // 2)
    temp_bg.paste(spaceship, position, spaceship)
    frames.append(temp_bg)

# Save the frames as a GIF
gif_path = "Alien Spaceship Moving.gif"
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# Memphis and its Necropolis 3

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Function pixelate the image
def pixelate(image, pixel_size):
    width, height = image.size
    image = image.resize(
        (width // pixel_size, height // pixel_size),
        Image.NEAREST
    )
    image = image.resize(
        (width, height),
        Image.NEAREST
    )
    return image

# Save image function
def save_image(image, path):
    if image.mode == 'RGBA':
        image = image.convert('RGB')
    image.save(path)

# Paths to the images
original_image_path = '/content/Memphis and its Necropolis 3.jpg'
overlay_image_path = '/content/Overlay 2.jpg'

# Load the original and overlay images
original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path).resize(original_image.size, Image.ANTIALIAS)

# Create an overlay with 50% transparency
overlay_with_transparency = Image.blend(original_image.convert("RGBA"), overlay_image.convert("RGBA"), 0.5)

# Create pixel effect with 50% transparency
pixel_size = 10  # Define the size of the pixelation effect
pixel_effect_from_overlay_transparency = pixelate(overlay_with_transparency, pixel_size)

# Display the images using matplotlib
fig, axs = plt.subplots(1, 4, figsize=(20, 5))

# Original image
axs[0].imshow(np.array(original_image))
axs[0].axis('off')
axs[0].set_title('Original Image')

# Original overlay image
axs[1].imshow(np.array(overlay_image))
axs[1].axis('off')
axs[1].set_title('Overlay Image')

# Overlay effect image with 50% transparency
axs[2].imshow(np.array(overlay_with_transparency))
axs[2].axis('off')
axs[2].set_title('Overlay Effect Image')

# Pixel effect image from overlay with 50% transparency
axs[3].imshow(np.array(pixel_effect_from_overlay_transparency))
axs[3].axis('off')
axs[3].set_title('Pixel Effect Image')

plt.tight_layout()
plt.show()

# Save the overlay effect image
overlay_effect_image_path = 'Memphis and its Necropolis 3 Overlay Image Effect.jpg'
save_image(overlay_with_transparency, overlay_effect_image_path)

# The path to the saved image
print(overlay_effect_image_path)

## Memphis and its Necropolis 3 (Explosion gif) (Self create)

from PIL import Image, ImageDraw, ImageFilter
import numpy as np

# Function to interpolate between two colors
def interpolate_color(color1, color2, factor: float):
    recip = 1 - factor
    return (
        int(color1[0] * recip + color2[0] * factor),
        int(color1[1] * recip + color2[1] * factor),
        int(color1[2] * recip + color2[2] * factor),
        255
    )

# Function to create explosion effects
def create_explosion_frame(frame_size, num_spikes, max_length, step, total_steps, color_set, center):
    frame = Image.new('RGBA', frame_size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(frame)

    # Calculate progression factor
    factor = step / total_steps

    # Define the length of spikes
    lengths = [max_length * factor * (i / num_spikes) for i in range(num_spikes)]

    for i, length in enumerate(lengths):
        angle = (360 / num_spikes) * i
        end_point = (
            center[0] + length * np.cos(np.radians(angle)),
            center[1] + length * np.sin(np.radians(angle))
        )
        # Interpolate between colors
        color = interpolate_color(color_set[0], color_set[1], i / num_spikes)
        draw.line([center, end_point], fill=color, width=2)

    # Apply a blur
    frame = frame.filter(ImageFilter.GaussianBlur(radius=int(2 * factor)))

    return frame

# Function to create the explosion gif
def create_explosive_background_gif(background_image_path, gif_filename, steps, max_length, num_spikes, color_sets):
    background_image = Image.open(background_image_path)
    background_image_size = background_image.size

    frames = []
    for i in range(steps):
        frame = background_image.copy()
        draw = ImageDraw.Draw(frame, "RGBA")
        for color_set in color_sets:
            center = (
                np.random.randint(0, background_image_size[0]),
                np.random.randint(0, background_image_size[1])
            )
            explosion_frame = create_explosion_frame(
                background_image_size, num_spikes, max_length, i+1, steps, color_set, center
            )
            frame.paste(explosion_frame, mask=explosion_frame)

        frames.append(frame)

    # Save the frames as an animated GIF
    frames[0].save(
        gif_filename,
        save_all=True,
        append_images=frames[1:],
        optimize=False,
        duration=50,
        loop=0
    )

# Parameters for the explosion GIF
background_image_path = '/content/Memphis and its Necropolis 3 Overlay Image Effect.jpg'
gif_filename = 'Explosive.gif'
steps = 30
max_length = 100
num_spikes = 30
color_sets = [
    [(255, 0, 0), (255, 165, 0)],
    [(255, 255, 0), (255, 69, 0)],
    [(255, 140, 0), (255, 20, 147)]  #
]

# Create and save the explosion GIF
create_explosive_background_gif(background_image_path, gif_filename, steps, max_length, num_spikes, color_sets)

# The filename where the GIF is saved
print(gif_filename)

"""# Part 2 Place 2"""

# Archaeological Site of Cyrene 1

from PIL import Image, ImageDraw, ImageFilter
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Archaeological Site of Cyrene 1.jpg'
overlay_image_path = '/content/Overlay 3.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Function overlay effect
def apply_overlay(original, overlay):
    overlay = overlay.resize(original.size)
    return Image.blend(original, overlay, 0.5)

# Function tilt-shift effect
def apply_tilt_shift(image):
    mask = Image.new("L", image.size, 0)
    draw = ImageDraw.Draw(mask)
    top = image.size[1] // 4
    bottom = top * 3
    draw.rectangle([(0, top), (image.size[0], bottom)], fill=255)
    mask_blur = mask.filter(ImageFilter.GaussianBlur(radius=image.size[1] // 10))

    # Apply the mask to the blurred image
    blurred = image.filter(ImageFilter.GaussianBlur(radius=image.size[1] // 20))
    return Image.composite(image, blurred, mask_blur)

# Function color halftone effect to an image
def apply_color_halftone(image, sample=10):
    if image.mode != 'RGB':
        image = image.convert('RGB')

    width, height = image.size
    halftone_image = Image.new('RGB', image.size)

    for channel_index, channel in enumerate(image.split()):
        channel_halftone = Image.new('L', image.size, 255)
        draw = ImageDraw.Draw(channel_halftone)

        for y in range(0, height, sample):
            for x in range(0, width, sample):
                brightness = channel.getpixel((x, y))
                diameter = ((255 - brightness) / 255) ** 0.5
                box = [x - diameter * sample / 2, y - diameter * sample / 2,
                       x + diameter * sample / 2, y + diameter * sample / 2]
                draw.ellipse(box, fill=0)

        halftone_channel = Image.merge('RGB', [
            channel_halftone if i == channel_index else Image.new('L', image.size, 255)
            for i in range(3)
        ])
        halftone_image = Image.composite(halftone_image, halftone_channel, channel_halftone)

    return halftone_image

# Apply overlay effect to get the image for halftone effect
overlay_effect_image = apply_overlay(original_image, overlay_image)

# Apply tilt-shift effect on the overlay effect image
tilt_shift_effect_image = apply_tilt_shift(overlay_effect_image)

# Apply halftone effect on the overlay effect image
halftone_effect_image = apply_color_halftone(overlay_effect_image)

# Display the images
fig, axs = plt.subplots(1, 5, figsize=(25, 5))

# Save the halftone effect image
save_path = 'Archaeological Site of Cyrene 1 Halftone Effect Image.jpg'  # Specify your save path
halftone_effect_image.save(save_path)

# Original image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay image
axs[1].imshow(overlay_image)
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Overlay effect image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Tilt-shift effect image
axs[3].imshow(tilt_shift_effect_image)
axs[3].set_title('Tilt-Shift Effect Image')
axs[3].axis('off')

# Halftone effect image
axs[4].imshow(halftone_effect_image, cmap='gray')
axs[4].set_title('Halftone Effect Image')
axs[4].axis('off')

plt.tight_layout()
plt.show()

# Archaeological Site of Cyrene 1 (Alien face pop up gif) (Self create)

from PIL import Image, ImageDraw

# Function to draw the alien
def draw_custom_alien(draw, center, size, color=(0, 255, 0)):
    alien_design = [
        "    1  1    ",
        "   111111   ",
        "  11111111  ",
        " 11  11  11 ",
        "1111 11 1111",
        " 1111111111 ",
        "  11111111  ",
        "   11  11   ",
        "   111111   ",
        "    1111    ",
        "     --     "
    ]

    # Determine the size of a single pixel
    pixel_size = size // 11

    # Draw the alien
    for y, row in enumerate(alien_design):
        for x, cell in enumerate(row):
            if cell == '1':
                draw.rectangle(
                    [
                        (center[0] + (x - 6) * pixel_size, center[1] + (y - 5) * pixel_size),
                        (center[0] + (x - 6) * pixel_size + pixel_size, center[1] + (y - 5) * pixel_size + pixel_size)
                    ],
                    fill=color
                )

# Load the image
background_path = '/content/Archaeological Site of Cyrene 1 Halftone Effect Image.jpg'
background = Image.open(background_path)

# Create frames for the GIF
frames = []
num_frames = 20
max_size = 400

for i in range(num_frames):
    frame = background.copy()
    draw = ImageDraw.Draw(frame)

    # Calculate the size of the alien
    size = int((i + 1) / num_frames * max_size)

    # Draw the alien on the frame
    draw_custom_alien(draw, (background.width // 2, background.height // 2), size)

    # Append the frame to the frames list
    frames.append(frame)

# Save the frames as a GIF
output_path = 'Alien Face Pop Up.gif'
frames[0].save(output_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# Archaeological Site of Cyrene 2

from PIL import Image, ImageFilter, ImageDraw, ImageChops, ImageOps
import numpy as np
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Archaeological Site of Cyrene 2.jpg'
overlay_image_path = '/content/Overlay 4.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Function overlay effect
def apply_overlay(original, overlay):
    overlay = overlay.resize(original.size, Image.ANTIALIAS)
    return Image.blend(original, overlay, 0.5)

# Function selectively colorize
def selective_colorization(image):
    image = image.convert('RGB')
    red, green, blue = image.split()
    np_green = np.array(green)
    mask = (np_green > 80) & (np_green < 200)
    np_green[:,:] = 0
    np_green[mask] = 255
    enhanced_green = Image.fromarray(np_green).convert('L')
    output = Image.merge("RGB", (red, enhanced_green, blue))
    return output

# Function infrared effect
def infrared_effect(image):
    image = image.convert('RGB')
    return ImageOps.invert(image)

# Apply overlay effect
overlay_effect_image = apply_overlay(original_image, overlay_image)

# Apply selective colorization effect using the overlay effect image
selective_colorization_image = selective_colorization(overlay_effect_image)

# Apply infrared effect using the overlay effect image
infrared_effect_image = infrared_effect(overlay_effect_image)

# Display all the images in a sequence
fig, axs = plt.subplots(1, 5, figsize=(25, 5))

# Save the glitched effect image
save_path = 'Archaeological Site of Cyrene 2 Infrared Effect Image.jpg'
infrared_effect_image.save(save_path)

# Original image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay image (original)
axs[1].imshow(overlay_image)
axs[1].set_title('Overlay Image (Original)')
axs[1].axis('off')

# Overlay effect image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Selective colorization effect image
axs[3].imshow(selective_colorization_image)
axs[3].set_title('Selective Colorization Effect Image')
axs[3].axis('off')

# Infrared effect image
axs[4].imshow(infrared_effect_image)
axs[4].set_title('Infrared Effect Image')
axs[4].axis('off')

plt.tight_layout()
plt.show()

# Archaeological Site of Cyrene 2 (Shooting energy ball gif) (Self create)

from PIL import Image, ImageDraw, ImageFilter
import numpy as np

# Load the image
image_path = '/content/Archaeological Site of Cyrene 2 Infrared Effect Image.jpg'
image = Image.open(image_path)

# Function create an animated effect
def create_variable_size_circles(image, num_circles=10, max_radius=50, color=(255, 0, 0)):
    draw = ImageDraw.Draw(image)
    width, height = image.size

    # Draw circles of varying sizes
    for _ in range(num_circles):
        center_x = np.random.randint(0, width)
        center_y = np.random.randint(0, height)
        radius = np.random.randint(5, max_radius)
        opacity = np.random.randint(100, 200)
        draw.ellipse((center_x - radius, center_y - radius, center_x + radius, center_y + radius), fill=color + (opacity,))

    return image

# Create frames for the GIF
frames = []
for i in range(20):
    frame = create_variable_size_circles(image.copy(), num_circles=20, max_radius=50, color=(255, 0, 0))
    frames.append(frame)

# Save the GIF
gif_path = 'Shooting Energy Ball.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

gif_path

"""# Part 2 Place 3"""

# Monasteries of Haghpat and Sanahin 1

from PIL import Image, ImageEnhance, ImageChops
import numpy as np
import matplotlib.pyplot as plt

# File paths adjusted for the current environment
original_image_path = '/content/Monasteries of Haghpat and Sanahin 1.jpg'
overlay_image_path = '/content/Overlay 7.jpg'

# Load the images
original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Function winter effect
def apply_winter_effect(image):
    blue_tint = ImageEnhance.Color(image).enhance(0.5)
    brightened = ImageEnhance.Brightness(blue_tint).enhance(1.1)
    snow_overlay = Image.new('RGB', image.size, color=(240, 240, 240))
    winter_image = Image.blend(brightened, snow_overlay, alpha=0.3)
    return winter_image

# Function autumn effect
def apply_autumn_effect(image):
    np_image = np.array(image)
    np_image[:, :, 0] = np.clip(np_image[:, :, 0] + 30, 0, 255)
    np_image[:, :, 1] = np.clip(np_image[:, :, 1] - 20, 0, 255)
    autumn_image = Image.fromarray(np_image)
    return autumn_image

# Function summer effect
def apply_summer_effect(image):
    saturated = ImageEnhance.Color(image).enhance(1.5)
    contrasted = ImageEnhance.Contrast(saturated).enhance(1.2)
    return contrasted

# Function spring effect
def apply_spring_effect(image):
    saturated = ImageEnhance.Color(image).enhance(1.2)
    brightened = ImageEnhance.Brightness(saturated).enhance(1.1)
    return brightened

# Function overlay effect
def apply_overlay_effect(base_image, overlay_image):
    overlay_resized = overlay_image.resize(base_image.size)
    combined_image = ImageChops.multiply(base_image, overlay_resized)
    return combined_image

# Apply the overlay effect to the original image
overlay_effect_image = apply_overlay_effect(original_image, overlay_image)

# Apply effects to create images for all seasons using the overlay effect image
winter_image = apply_winter_effect(overlay_effect_image)
autumn_image = apply_autumn_effect(overlay_effect_image)
summer_image = apply_summer_effect(overlay_effect_image)
spring_image = apply_spring_effect(overlay_effect_image)

# Function to save images
def save_image(image, image_name):
    image.save(f'/content/{image_name}.jpg')

# Save the seasonal images
save_image(winter_image, 'Monasteries of Haghpat and Sanahin 1 Winter Effect Image')
save_image(autumn_image, 'Monasteries of Haghpat and Sanahin 1 Autumn Effect Image')
save_image(summer_image, 'Monasteries of Haghpat and Sanahin 1 Summer Effect Image')
save_image(spring_image, 'Monasteries of Haghpat and Sanahin 1 Spring Effect Image')

# Display the original, overlay, and the seasonal effect images
fig, axs = plt.subplots(1, 7, figsize=(25, 10))

# Original image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay image
axs[1].imshow(overlay_image)
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Overlay effect image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Winter effect image
axs[3].imshow(winter_image)
axs[3].set_title('Winter Effect Image')
axs[3].axis('off')

# Autumn effect image
axs[4].imshow(autumn_image)
axs[4].set_title('Autumn Effect Image')
axs[4].axis('off')

# Summer effect image
axs[5].imshow(summer_image)
axs[5].set_title('Summer Effect Image')
axs[5].axis('off')

# Spring effect image
axs[6].imshow(spring_image)
axs[6].set_title('Spring Effect Image')
axs[6].axis('off')

# Display the images
plt.tight_layout()
plt.show()

# Monasteries of Haghpat and Sanahin 1 (Winter gif) (Self create)

from PIL import Image, ImageDraw
import random

# Load the winter effect image
image_path = '/content/Monasteries of Haghpat and Sanahin 1 Winter Effect Image.jpg'
winter_image = Image.open(image_path)

# Function to add snowflakes
def add_snowflakes(image, num_snowflakes=100):
    snow_image = image.copy()
    draw = ImageDraw.Draw(snow_image)

    # Add snowflakes
    for _ in range(num_snowflakes):
        x = random.randint(0, snow_image.width)
        y = random.randint(0, snow_image.height)
        draw.ellipse((x, y, x + 8, y + 8), fill='white')

    return snow_image

# Create frames for the GIF
frames = []
num_frames = 10
for _ in range(num_frames):
    frame = add_snowflakes(winter_image, num_snowflakes=50)
    frames.append(frame)

# Save the frames as a GIF
gif_path = 'Winter.gif'
frames[0].save(
    gif_path,
    save_all=True,
    append_images=frames[1:],
    optimize=False,
    duration=200,
    loop=0
)

# Monasteries of Haghpat and Sanahin 1 (Autumn gif) (Self create)

from PIL import Image, ImageDraw
import random

# Load the autumn effect image
image_path = '/content/Monasteries of Haghpat and Sanahin 1 Autumn Effect Image.jpg'
autumn_image = Image.open(image_path)

# Function to generate a leaf
def generate_leaf(max_width, max_height):
    leaf_size = random.randint(3, 6)
    x = random.randint(0, max_width)
    y = random.randint(-max_height // 2, max_height // 2)
    return {'position': (x, y), 'size': leaf_size, 'color': random.choice(leaf_colors)}

# Function to draw leaves on the image
def draw_leaves(image, leaves):
    leaves_image = image.copy()
    draw = ImageDraw.Draw(leaves_image)
    for leaf in leaves:
        x, y = leaf['position']
        size = leaf['size']
        leaf_color = leaf['color']
        draw.ellipse((x, y, x + size, y + size), fill=leaf_color)
    return leaves_image

# Function to update the position of leaves
def update_leaves(leaves, max_height):
    for leaf in leaves:
        leaf['position'] = (leaf['position'][0] + random.randint(-2, 2), leaf['position'][1] + random.randint(3, 6))
        if leaf['position'][1] > max_height:
            leaf['position'] = (leaf['position'][0], -20)

# Settings for the GIF
num_leaves = 30
leaf_colors = [(255, 99, 71), (255, 165, 0), (184, 134, 11)]
num_frames = 40

# Generate initial leaves
leaves = [generate_leaf(autumn_image.width, autumn_image.height) for _ in range(num_leaves)]

# Create frames for the autumn GIF
autumn_frames = []
for _ in range(num_frames):
    frame = draw_leaves(autumn_image, leaves)
    autumn_frames.append(frame)
    update_leaves(leaves, autumn_image.height)

# Save the frames as an autumn GIF
gif_path = 'Autumn.gif'
autumn_frames[0].save(
    gif_path,
    save_all=True,
    append_images=autumn_frames[1:],
    optimize=False,
    duration=100,
    loop=0
)

# Monasteries of Haghpat and Sanahin 1 (Summer gif) (Self create)

from PIL import Image, ImageDraw
import math

# Function draw sun
def draw_brighter_sun(image, position, radius, color=(255, 255, 224), ray_length=40, ray_width=2):
    sun_image = image.copy()
    draw = ImageDraw.Draw(sun_image)
    x, y = position
    draw.ellipse((x-radius, y-radius, x+radius, y+radius), fill=color)

    for i in range(0, 360, 30):
        end_x = x + math.cos(math.radians(i)) * (radius + ray_length)
        end_y = y + math.sin(math.radians(i)) * (radius + ray_length)
        draw.line((x, y, end_x, end_y), fill=color, width=ray_width)

    return sun_image

# Load the image
image_path = '/content/Monasteries of Haghpat and Sanahin 1 Summer Effect Image.jpg'
image = Image.open(image_path)

# Create frames for a summer GIF
summer_frames_with_brighter_sun = []
sun_radius = 50
sun_color = (255, 255, 224)
ray_length = 20
ray_width = 4
num_frames = 20

for i in range(num_frames):
    sun_position = (int(image.width / num_frames * i), 75)
    frame_with_sun = draw_brighter_sun(image, sun_position, sun_radius, sun_color, ray_length, ray_width)
    summer_frames_with_brighter_sun.append(frame_with_sun)

# Save the frames as a summer GIF
gif_path = 'Summer.gif'
summer_frames_with_brighter_sun[0].save(
    gif_path,
    save_all=True,
    append_images=summer_frames_with_brighter_sun[1:],
    optimize=False,
    duration=100,
    loop=0
)

# Monasteries of Haghpat and Sanahin 1 (Spring gif) (Self create)

from PIL import Image, ImageDraw, ImageSequence, ImageFilter, ImageOps
import numpy as np

# Load the backround image
background_image_path = '/content/Monasteries of Haghpat and Sanahin 1 Spring Effect Image.jpg'
background = Image.open(background_image_path)

# Create canvas with the same size as the background image
width, height = background.size
canvas = Image.new("RGBA", (width, height))

# Define the draw object
draw = ImageDraw.Draw(canvas)

# Function to add flowers on the bottom
def draw_flowers(draw_obj, width, height, num_flowers=200):
    for _ in range(num_flowers):
        x = np.random.randint(0, width)
        y = np.random.randint(height*3//4, height)
        color = np.random.choice(["pink", "yellow", "red", "white", "purple"])
        draw_obj.ellipse([x, y, x+10, y+10], fill=color)

# Function to add falling petals
def draw_falling_petals(draw_obj, width, height, num_petals=20, offset=0):
    for _ in range(num_petals):
        x = np.random.randint(0, width)
        y = (np.random.randint(0, height//4) + offset) % height
        draw_obj.ellipse([x, y, x+5, y+10], fill="lightpink", outline="pink")

# Function to create a frame of the GIF
def create_frame(background, offset):
    frame = background.copy()
    draw = ImageDraw.Draw(frame)
    draw_flowers(draw, width, height)
    draw_falling_petals(draw, width, height, offset=offset)
    return frame

# Create frames for the GIF
frames = []
for i in range(20):
    frame = create_frame(background, i * (height // 20))
    frames.append(frame)

# Save the frames as a GIF
gif_path = "Spring.gif"
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# Monasteries of Haghpat and Sanahin 2

from PIL import Image
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Monasteries of Haghpat and Sanahin 2.jpg'
overlay_image_path = '/content/Overlay 8.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Resize the overlay image to match the original image size
overlay_image_resized = overlay_image.resize(original_image.size)

# Create an overlay effect by blending the original and the overlay images
overlay_effect_image = Image.blend(original_image, overlay_image_resized, alpha=0.5)

# Save the overlay effect image
overlay_effect_image_path = 'Monasteries of Haghpat and Sanahin 2 Overlay Effect Image.jpg'
overlay_effect_image.save(overlay_effect_image_path)

# Display the images using matplotlib
fig, ax = plt.subplots(1, 3, figsize=(15, 5))

# Original image
ax[0].imshow(original_image)
ax[0].set_title('Original Image')
ax[0].axis('off')

# Overlay image
ax[1].imshow(overlay_image_resized)
ax[1].set_title('Overlay Image')
ax[1].axis('off')

# Overlay effect image
ax[2].imshow(overlay_effect_image)
ax[2].set_title('Overlay Effect Image')
ax[2].axis('off')

plt.show()

# Monasteries of Haghpat and Sanahin 2 (Moving fire gif) (Self create)

from PIL import Image, ImageDraw
import random

# function to draw house on fire
def draw_larger_fire(image, flame_base_height, flame_peak_height, num_flames):
    fire_image = image.copy()
    draw = ImageDraw.Draw(fire_image)
    width, height = fire_image.size

    # Draw flames at random positions
    for _ in range(num_flames):
        flame_width = random.randint(200, 200)
        base_height = random.randint(height - flame_base_height - 100, height - 100)
        peak_height = base_height - random.randint(flame_peak_height, flame_peak_height * 2)
        flame_x = random.randint(0, width)
        draw.polygon([
            (flame_x, base_height),
            (flame_x + flame_width // 2, peak_height),
            (flame_x + flame_width, base_height)
        ], fill="orange")
        fire_image = fire_image.filter(ImageFilter.GaussianBlur(radius=3))
    return fire_image

# Load the image
image_path = '/content/Monasteries of Haghpat and Sanahin 2 Overlay Effect Image.jpg'
background_image = Image.open(image_path)

# Create frames for the GIF
fire_gif_frames = []
flame_base_height = 5
flame_peak_height = 200
num_flames = 100

# Generate multiple frames for the animation with larger, semi-random flames
for _ in range(20):
    frame = draw_larger_fire(background_image, flame_base_height, flame_peak_height, num_flames)
    fire_gif_frames.append(frame)

# Save the frames as a GIF
gif_path = 'Fire.gif'
fire_gif_frames[0].save(
    gif_path,
    save_all=True,
    append_images=fire_gif_frames[1:],
    optimize=False,
    duration=300,
    loop=0
)

# Return the path of the saved GIF
gif_path

# Monasteries of Haghpat and Sanahin 3

from PIL import Image, ImageFilter, ImageChops
import matplotlib.pyplot as plt
import numpy as np

# Load the images
original_image_path = 'Monasteries of Haghpat and Sanahin 3.jpg'
overlay_image_path = 'Overlay 6.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Ensure overlay image is the same size as the original image
overlay_image = overlay_image.resize(original_image.size)

# Create an overlay image
overlay_effect_image = ImageChops.multiply(original_image, overlay_image)

# Convert images to grayscale for Prewitt filter
gray_original_image = original_image.convert('L')
gray_overlay_effect_image = overlay_effect_image.convert('L')

# Prewitt operator kernels
kernelx = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])
kernely = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]])

def prewitt_filter(image):
    x = np.array(image.filter(ImageFilter.Kernel((3, 3), kernelx.flatten(), 1, 0)))
    y = np.array(image.filter(ImageFilter.Kernel((3, 3), kernely.flatten(), 1, 0)))

    magnitude = np.sqrt(x**2 + y**2)

    magnitude = (magnitude / magnitude.max()) * 255
    return Image.fromarray(magnitude.astype('uint8'))

# Apply Prewitt filter
prewitt_overlay_effect = prewitt_filter(gray_overlay_effect_image)

def make_anaglyph(image, offset=(50, 0)):
    r, g, b = image.split()
    r = ImageChops.offset(r, offset[0], offset[1])
    return Image.merge('RGB', (r, g, b))

# Apply the anaglyph function
anaglyph_overlay_effect = make_anaglyph(overlay_effect_image, offset=(50, 0))

# Display the images
fig, axs = plt.subplots(1, 5, figsize=(20, 4))

# Original image
axs[0].imshow(original_image)
axs[0].axis('off')
axs[0].set_title('Original Image')

# Overlay image
axs[1].imshow(overlay_image)
axs[1].axis('off')
axs[1].set_title('Overlay Image')

# Overlay effect image
axs[2].imshow(overlay_effect_image)
axs[2].axis('off')
axs[2].set_title('Overlay Effect Image')

# Prewitt filter effect
axs[3].imshow(prewitt_overlay_effect, cmap='gray')
axs[3].axis('off')
axs[3].set_title('Prewitt Filter Effect')

# Anaglyph 3D effect image with higher offset
axs[4].imshow(anaglyph_overlay_effect)
axs[4].axis('off')
axs[4].set_title('3D Anaglyph Effect with Higher Offset')

plt.tight_layout()
plt.show()

# Save the Anaglyph 3D effect image with higher offset
save_path = 'Monasteries of Haghpat and Sanahin 3 3D Anaglyph Effect with Higher Offset.jpg'
anaglyph_overlay_effect.save(save_path)

# Monasteries of Haghpat and Sanahin 3 (Moving monster gif) (Online source image)

from PIL import Image

# Define paths for images
new_background_path = '/content/Monasteries of Haghpat and Sanahin 3 3D Anaglyph Effect with Higher Offset.jpg'
new_dragon_path = '/content/For gif used 2.jpg'

# Open background and dragon images
new_background = Image.open(new_background_path)
new_dragon = Image.open(new_dragon_path)

new_scaled_dragon_width = int(new_background.size[0] / 2)
new_scaled_dragon_height = int(new_dragon.size[1] * (new_scaled_dragon_width / new_dragon.size[0]))
new_scaled_dragon = new_dragon.resize((new_scaled_dragon_width, new_scaled_dragon_height), Image.ANTIALIAS)

# Define the number of frames for the animation
new_n_frames = 10
new_frames_big = []

for i in range(new_n_frames):
    new_frame_big = Image.new("RGBA", new_background.size)
    new_frame_big.paste(new_background, (0, 0))

    new_dragon_position_x_big = int((new_background.size[0] - new_scaled_dragon.width) / (new_n_frames - 1) * i)
    new_dragon_position_y_big = int(new_background.size[1] * 0.1)  # Let's keep the dragon a bit above the ground

    new_frame_big.paste(new_scaled_dragon, (new_dragon_position_x_big, new_dragon_position_y_big), new_scaled_dragon)

    new_frame_big_rgb = new_frame_big.convert("RGB")
    new_frames_big.append(new_frame_big_rgb)

# Save the frames as a GIF with the bigger dragon
new_gif_path_big = 'Moving Monster.gif'
new_frames_big[0].save(new_gif_path_big, save_all=True, append_images=new_frames_big[1:], optimize=False, duration=100, loop=0)

"""# Part 2 Place 4"""

#Sansa, Buddhist Mountain Monasteries in Korea 1

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Function sunlight effect
def apply_sunlight_effect(image, intensity=0.3, color=(255, 255, 150)):
    height, width = image.shape[:2]
    overlay = np.full((height, width, 3), color, dtype=np.uint8)
    return cv2.addWeighted(overlay, intensity, image, 1 - intensity, 0)

# Function light trails effect
def apply_light_trails(image, kernel_size, iterations):
    kernel = np.zeros((kernel_size, kernel_size))
    kernel[int((kernel_size - 1) / 2), :] = np.ones(kernel_size)
    kernel /= kernel_size
    for _ in range(iterations):
        image = cv2.filter2D(image, -1, kernel)
    return image

# Function overlay images
def overlay_images(background, overlay, alpha=0.5):
    return cv2.addWeighted(background, 1 - alpha, overlay, alpha, 0)

# Load the images
original_image_path = '/content/Sansa, Buddhist Mountain Monasteries in Korea 1.jpg'
overlay_image_path = '/content/Overlay 9.jpg'
original_image = cv2.imread(original_image_path)
overlay_image = cv2.imread(overlay_image_path)

# Resize the overlay image
overlay_image_resized = cv2.resize(overlay_image, (original_image.shape[1], original_image.shape[0]))

# Apply sunlight effect
sunlight_image = apply_sunlight_effect(original_image.copy(), intensity=0.3, color=(255, 255, 150))

# Create overlay effect image
overlay_effect_image_with_sunlight = overlay_images(sunlight_image, overlay_image_resized, alpha=0.5)

# Apply light trails effect
time_lapse_overlay_effect_with_sunlight = apply_light_trails(overlay_effect_image_with_sunlight, kernel_size=50, iterations=5)

# Function to save an image to a file
def save_image(image, file_path):
    cv2.imwrite(file_path, image)

# Display the images
fig, axs = plt.subplots(1, 5, figsize=(20, 5))

# Display original image
axs[0].imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
axs[0].set_title('Original Image')
axs[0].axis('off')

# Display sunlight intensity effect image
axs[1].imshow(cv2.cvtColor(sunlight_image, cv2.COLOR_BGR2RGB))
axs[1].set_title('Sunlight Intensity Effect Image')
axs[1].axis('off')

# Display original overlay image
axs[2].imshow(cv2.cvtColor(overlay_image_resized, cv2.COLOR_BGR2RGB))
axs[2].set_title('Original Overlay Image')
axs[2].axis('off')

# Display overlay effect image with sunlight
axs[3].imshow(cv2.cvtColor(overlay_effect_image_with_sunlight, cv2.COLOR_BGR2RGB))
axs[3].set_title('Overlay Effect Image')
axs[3].axis('off')

# Display time lapse effect with sunlight
axs[4].imshow(cv2.cvtColor(time_lapse_overlay_effect_with_sunlight, cv2.COLOR_BGR2RGB))
axs[4].set_title('Time Lapse Effect')
axs[4].axis('off')

save_image_path = 'Sansa, Buddhist Mountain Monasteries in Korea 1 Overlay Effect Image.jpg'
save_image(overlay_effect_image_with_sunlight, save_image_path)

plt.tight_layout()
plt.show()

#Sansa, Buddhist Mountain Monasteries in Korea 1 (Welcome to Beopjusa Temple Text gif) (Self create)

from PIL import Image, ImageDraw, ImageFont

# Load the image
image_path = '/content/Sansa, Buddhist Mountain Monasteries in Korea 1 Overlay Effect Image.jpg'
original_image = Image.open(image_path)

# Define the text to display
text_line_1 = "Welcome to Beopjusa Temple,"
text_line_2 = "Hall of Eight Pictures"

# Use a font
font_path = "LiberationSerif-Bold.ttf"
font = ImageFont.truetype(font_path, size=60)

# Function to add text to the frame
def draw_text(draw, text, font, image_size, offset_y=0):
    text_width, text_height = draw.textsize(text, font=font)
    position = ((image_size[0] - text_width) // 2, (image_size[1] - text_height) // 2 + offset_y)
    draw.text(position, text, font=font, fill="black")

# Create a list to hold the frames for the GIF
frames = []

# Calculate the duration each frame
frame_duration = 50

# Generate frames for the first line of text
for i in range(len(text_line_1) + 1):
    frame = original_image.copy()
    draw = ImageDraw.Draw(frame)
    draw_text(draw, text_line_1[:i], font, original_image.size)
    frames.append(frame)

# Generate frames for the second line of text
for i in range(len(text_line_2) + 1):
    frame = original_image.copy()
    draw = ImageDraw.Draw(frame)
    draw_text(draw, text_line_1, font, original_image.size)
    draw_text(draw, text_line_2[:i], font, original_image.size, offset_y=50)
    frames.append(frame)

# Save the frames as a GIF
gif_path = 'Welcome to Beopjusa Temple Text.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=frame_duration, loop=0)

#Sansa, Buddhist Mountain Monasteries in Korea 2

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Function overlay images
def overlay_images(background, overlay, alpha=0.5):
    return cv2.addWeighted(background, 1 - alpha, overlay, alpha, 0)

# Function pixelate an image
def pixelate_image(image, pixel_size=10):
    height, width = image.shape[:2]
    temp = cv2.resize(image, (width//pixel_size, height//pixel_size), interpolation=cv2.INTER_LINEAR)
    return cv2.resize(temp, (width, height), interpolation=cv2.INTER_NEAREST)

# Function change the color to hue
def change_color_effect(image):
    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    hsv_image[:, :, 0] = (hsv_image[:, :, 0] + 40) % 180
    return cv2.cvtColor(hsv_image, cv2.COLOR_HSV2BGR)

# Function to save an image to a file
def save_image(image, file_path):
    cv2.imwrite(file_path, image)

# Load the images
original_image_path = '/content/Sansa, Buddhist Mountain Monasteries in Korea 2.jpg'
overlay_image_path = '/content/Overlay 10.jpg'
original_image = cv2.imread(original_image_path)
overlay_image = cv2.imread(overlay_image_path)

# Resize the overlay image
overlay_image_resized = cv2.resize(overlay_image, (original_image.shape[1], original_image.shape[0]))

# Create overlay effect image
overlay_effect_image = overlay_images(original_image, overlay_image_resized, alpha=0.5)

# Create pixel effect image
pixel_effect_image = pixelate_image(overlay_effect_image, pixel_size=10)

# Apply color changing effect
color_changed_effect_image = change_color_effect(pixel_effect_image)

# Save the color changed effect image
color_changed_effect_image_path = 'Sansa, Buddhist Mountain Monasteries in Korea 2 Color Changed Effect Image.jpg'
save_image(color_changed_effect_image, color_changed_effect_image_path)

# Display the images
fig, axs = plt.subplots(1, 5, figsize=(25, 5))

# Display original image
axs[0].imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
axs[0].set_title('Original Image')
axs[0].axis('off')

# Display overlay image
axs[1].imshow(cv2.cvtColor(overlay_image_resized, cv2.COLOR_BGR2RGB))
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Display overlay effect image
axs[2].imshow(cv2.cvtColor(overlay_effect_image, cv2.COLOR_BGR2RGB))
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Display pixel effect image
axs[3].imshow(cv2.cvtColor(pixel_effect_image, cv2.COLOR_BGR2RGB))
axs[3].set_title('Pixel Effect Image')
axs[3].axis('off')

# Display color changed effect image
axs[4].imshow(cv2.cvtColor(color_changed_effect_image, cv2.COLOR_BGR2RGB))
axs[4].set_title('Color Changing Effect Image')
axs[4].axis('off')

plt.tight_layout()
plt.show()

#Sansa, Buddhist Mountain Monasteries in Korea 2 (Laser beam gif) (Self create)

from PIL import Image, ImageDraw
import numpy as np
import imageio

# Function add laser beams
def add_laser_beams(image, num_beams, beam_color, beam_length, beam_thickness):
    draw = ImageDraw.Draw(image)
    width, height = image.size
    for _ in range(num_beams):
        x_start = np.random.randint(0, width)
        y_start = 0
        draw.line((x_start, y_start, x_start, y_start + beam_length),
                  fill=beam_color, width=beam_thickness)
    return image

# Load the background image
background_image_path = '/content/Sansa, Buddhist Mountain Monasteries in Korea 2 Color Changed Effect Image.jpg'
background_image = Image.open(background_image_path)

# Define the parameters for the laser beams
num_beams = 50
beam_color = (255, 0, 0)
beam_length = background_image.height
beam_thickness = 2

# Create a GIF
gif_path = 'Laser Beam Pixel.gif'
writer = imageio.get_writer(gif_path, fps=5, loop=0)

# Create frames with laser beams and add them to the GIF
for i in range(20):
    frame = background_image.copy()
    frame = add_laser_beams(frame, num_beams, beam_color, beam_length, beam_thickness)

    # Pixelate the frame by resizing down and then up
    small_frame = frame.resize((frame.width // 10, frame.height // 10), resample=Image.NEAREST)
    pixel_frame = small_frame.resize(frame.size, Image.NEAREST)

    # Add the pixelated frame to the GIF
    writer.append_data(np.array(pixel_frame))

# Close the writer to finish the GIF
writer.close()

print(f"GIF saved to {gif_path}")

#Sansa, Buddhist Mountain Monasteries in Korea 3

from PIL import Image, ImageChops, ImageEnhance
import numpy as np
import matplotlib.pyplot as plt

# Function glitch effect image
def glitch_image(image):
    # Convert to RGB
    image_rgb = image.convert('RGB')

    # Glitch effect parameters
    offset = 10
    interval = 5

    # Split the image into RGB channels
    channels = [np.array(c) for c in image_rgb.split()]

    # Apply glitch effect by offsetting channels
    for i in range(0, image_rgb.size[1], interval):
        for c in channels:
            c[i:i+interval] = np.roll(c[i:i+interval], np.random.randint(-offset, offset), axis=1)

    # Merge channels and convert to image
    np_image = np.dstack(channels)
    return Image.fromarray(np_image)

# Load the images
original_image_path = '/content/Sansa, Buddhist Mountain Monasteries in Korea 3.jpg'
overlay_image_path = '/content/Overlay 11.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Ensure overlay image is the same size as the original image
overlay_image = overlay_image.resize(original_image.size)

# Create an overlay image
overlay_effect_image = ImageChops.multiply(original_image, overlay_image)

# Apply glitch effect
glitched_image = glitch_image(overlay_effect_image)

# Display the images
fig, axs = plt.subplots(1, 4, figsize=(20, 5))

# Original image
axs[0].imshow(original_image)
axs[0].axis('off')
axs[0].set_title('Original Image')

# Overlay image
axs[1].imshow(overlay_image)
axs[1].axis('off')
axs[1].set_title('Overlay Image')

# Overlay effect image
axs[2].imshow(overlay_effect_image)
axs[2].axis('off')
axs[2].set_title('Overlay Effect Image')

# Glitched image effect
axs[3].imshow(glitched_image)
axs[3].axis('off')
axs[3].set_title('Glitched Image Effect')

plt.tight_layout()
plt.show()

# Save the glitched image effect
save_path = 'Sansa, Buddhist Mountain Monasteries in Korea 3 Glitched Effect Image.jpg'
glitched_image.save(save_path)

#Sansa, Buddhist Mountain Monasteries in Korea 3 (Toxic storm gif) (Self Create)

from PIL import Image, ImageDraw
import numpy as np

# Function toxic sandstorm effect
def create_toxic_sandstorm_effect(bg_width, bg_height, density=0.5):
    toxic_sandstorm = Image.new('RGBA', (bg_width, bg_height))
    for x in range(bg_width):
        for y in range(bg_height):
            if np.random.rand() <= density:
                opacity = np.random.randint(50, 150)
                toxic_sandstorm.putpixel((x, y), (0, 255, 0, opacity))
    return toxic_sandstorm

# Function to create frames
def create_toxic_sandstorm_frames(background, num_frames=20, speed=5):
    bg_width, bg_height = background.size
    toxic_sandstorm_effect = create_toxic_sandstorm_effect(bg_width, bg_height)

    frames = []
    for i in range(num_frames):
        frame = background.copy()
        offset = (speed * i) % bg_width
        toxic_sandstorm_moving = Image.new('RGBA', (bg_width, bg_height))
        toxic_sandstorm_moving.paste(toxic_sandstorm_effect, (offset - bg_width, 0))
        toxic_sandstorm_moving.paste(toxic_sandstorm_effect, (offset, 0))

        frame.paste(toxic_sandstorm_moving, mask=toxic_sandstorm_moving)
        frames.append(frame)
    return frames

# Load the background image for the GIF
background_path = '/content/Sansa, Buddhist Mountain Monasteries in Korea 3 Glitched Effect Image.jpg'
background = Image.open(background_path)

# Create toxic sandstorm frames
frames = create_toxic_sandstorm_frames(background, num_frames=20, speed=20)

# Save the frames as a GIF
toxic_sandstorm_gif_path = 'Toxic storm.gif'
frames[0].save(toxic_sandstorm_gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=50, loop=0)

"""# Part 2 Place 5"""

# Nui National Park

from PIL import Image, ImageChops
import numpy as np
import matplotlib.pyplot as plt

# Function anaglyph image
def create_anaglyph(image, offset_value=15):
    image = image.convert('RGB')

    # Split the image into individual bands
    r, g, b = image.split()

    # Offset the red and cyan channels
    r = ImageChops.offset(r, offset_value, 0)
    g = ImageChops.offset(g, -offset_value, 0)
    b = ImageChops.offset(b, -offset_value, 0)

    # Merge the bands back together
    anaglyph = Image.merge('RGB', (r, g, b))

    return anaglyph

# Function to save the TV frame effect image
def save_tv_frame_image(image, file_path):
    image.save(file_path)

# Paths to the images
image_paths = [
    '/content/Rapa Nui National Park 1.jpg',
    '/content/Rapa Nui National Park 2.jpg',
    '/content/Rapa Nui National Park 3.jpg',
    '/content/Rapa Nui National Park 4.jpg',
]

# Load the images into a list
images = [Image.open(path) for path in image_paths]

# Determine the size for the composite image
width, height = images[0].size
composite_image_size = (width * 2, height * 2)

# Create a new image to combine the four images into a grid
composite_image = Image.new('RGB', composite_image_size)

# Paste the images into the composite image
composite_image.paste(images[0], (0, 0))
composite_image.paste(images[1], (width, 0))
composite_image.paste(images[2], (0, height))
composite_image.paste(images[3], (width, height))

# Create infrared effect
infrared_array = 255 - np.array(composite_image)
infrared_image = Image.fromarray(infrared_array)

# Apply the anaglyph effect
anaglyph_from_infrared = create_anaglyph(infrared_image)

# Define the border size
border_size = 50

# Create a new image with a border for the TV frame
tv_frame_image = Image.new('RGB',
                           (anaglyph_from_infrared.width + 2*border_size,
                            anaglyph_from_infrared.height + 2*border_size),
                           "black")

# Paste the anaglyph image onto the tv frame
tv_frame_image.paste(anaglyph_from_infrared, (border_size, border_size))

# Save the TV frame effect image
save_tv_frame_image(tv_frame_image, 'Rapa Nui National Park Tv Frame Effect Image.jpg')

# Display the original composite, the infrared effect, the anaglyph, and the TV frame images
fig, axs = plt.subplots(1, 4, figsize=(24, 6))

# Display the composite image
axs[0].imshow(composite_image)
axs[0].axis('off')
axs[0].set_title('4 Images in Frame')

# Display the infrared effect image
axs[1].imshow(infrared_image)
axs[1].axis('off')
axs[1].set_title('Infrared Effect Image')

# Display the anaglyph image
axs[2].imshow(anaglyph_from_infrared)
axs[2].axis('off')
axs[2].set_title('Anaglyph Effect Image')

# Display the TV frame image
axs[3].imshow(tv_frame_image)
axs[3].axis('off')
axs[3].set_title('TV Frame Effect Image')

plt.tight_layout()
plt.show()

# Nui National Park (Emergency alert gif) (Self create)

from PIL import Image, ImageDraw, ImageFont

# Define the paths to the images
emergency_alert_bg_path = '/content/Rapa Nui National Park Tv Frame Effect Image.jpg'
signal_lost_image_path = '/content/For gif used 3.jpg'

# Load the images
emergency_alert_bg = Image.open(emergency_alert_bg_path)
signal_lost_image = Image.open(signal_lost_image_path)

# Resize the signal lost image to match the emergency alert background size
signal_lost_image_resized = signal_lost_image.resize(emergency_alert_bg.size, Image.ANTIALIAS)

# Define the number of frames and other GIF parameters
num_frames = 60
display_frames = 30
font_path = "LiberationSerif-Bold.ttf"
font_size = 80
font = ImageFont.truetype(font_path, font_size)
text = "EMERGENCY ALERT"
text_color = (255, 0, 0)

# Create frames for the GIF
frames = []

# Create frames for displaying "EMERGENCY ALERT"
for i in range(display_frames):
    frame = emergency_alert_bg.copy()
    draw = ImageDraw.Draw(frame)
    w, h = draw.textsize(text, font=font)
    position = ((frame.width - w) / 2, (frame.height - h) / 2)
    draw.text(position, text, font=font, fill=text_color)
    frames.append(frame)

# Add the signal lost frames
for i in range(num_frames - display_frames):
    frames.append(signal_lost_image_resized)

# Save the frames as a GIF
gif_path = 'Emergency Alert & Signal Lost.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=int(3000/display_frames), loop=0)

"""# Part 2 Place 6"""

# Paris, Banks of the Seine 1

from PIL import Image, ImageEnhance, ImageDraw, ImageOps, ImageChops
import numpy as np
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Paris, Banks of the Seine 1.jpg'
overlay_image_path = '/content/Overlay 12.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Ensure the overlay image is the same size as the original image
overlay_image = overlay_image.resize(original_image.size)

# Increase contrast
enhancer = ImageEnhance.Contrast(original_image)
contrast_effect_image = enhancer.enhance(2.0)

# Make the overlay image clearer
overlay_image.putalpha(200)

# Create a bombing sight effect
bombing_sight_effect_image = contrast_effect_image.copy()
draw = ImageDraw.Draw(bombing_sight_effect_image)
width, height = bombing_sight_effect_image.size

# Define circle properties and crosshair properties
circle_center = (width // 2, height // 2)
circle_radius = min(width, height) // 4
crosshair_length = 20
line_width = 5
circle_color = (255, 0, 0, 128)

# Draw the circle and crosshairs
draw.ellipse((circle_center[0] - circle_radius, circle_center[1] - circle_radius,
              circle_center[0] + circle_radius, circle_center[1] + circle_radius),
             outline=circle_color, width=line_width)
draw.line((circle_center[0], circle_center[1] - crosshair_length,
           circle_center[0], circle_center[1] + crosshair_length),
          fill=circle_color, width=line_width)
draw.line((circle_center[0] - crosshair_length, circle_center[1],
           circle_center[0] + crosshair_length, circle_center[1]),
          fill=circle_color, width=line_width)

# Create an overlay effect image
overlay_effect_image = Image.alpha_composite(bombing_sight_effect_image.convert("RGBA"), overlay_image)

# Define the selective colorization function
def selective_colorize_red(image):
    if image.mode != 'RGB':
        image = image.convert('RGB')
    data = np.array(image)
    red, green, blue = data[:,:,0], data[:,:,1], data[:,:,2]
    red_dominant = (red > green) & (red > blue)
    intensity_threshold = 60
    not_too_dark = red > intensity_threshold
    mask = red_dominant & not_too_dark
    data[~mask] = 0

    return Image.fromarray(data)

# Define a range for selective colorization
def selective_colorization_green(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    lower_green = np.array([40, 40, 40])
    upper_green = np.array([80, 255, 255])
    mask = cv2.inRange(hsv, lower_green, upper_green)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray_3_channel = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
    color_selective = np.where(mask[:,:,None] != 0, image, gray_3_channel)
    return color_selective

# Apply selective colorization
selective_colorization_effect_image = selective_colorize_red(overlay_effect_image)

# Function to save the selective colorization effect image
def save_selective_colorization_effect(image, file_path):
    image.save(file_path)

# Save the selective colorization effect image
save_path = 'Paris, Banks of the Seine 1 Selective Colorization Effect Image.jpg'
save_selective_colorization_effect(selective_colorization_effect_image, save_path)

# Display the images in the requested order
fig, axs = plt.subplots(1, 6, figsize=(30, 6))

# Display the original image
axs[0].imshow(original_image)
axs[0].axis('off')
axs[0].set_title('Original Image')

# Display the contrast effect image
axs[1].imshow(contrast_effect_image)
axs[1].axis('off')
axs[1].set_title('Contrast Effect Image')

# Display the bombing sight effect image
axs[2].imshow(bombing_sight_effect_image)
axs[2].axis('off')
axs[2].set_title('Bombing Sight Effect Image')

# Display the overlay image
axs[3].imshow(overlay_image)
axs[3].axis('off')
axs[3].set_title('Overlay Image')

# Display the overlay effect image
axs[4].imshow(overlay_effect_image)
axs[4].axis('off')
axs[4].set_title('Overlay Effect Image')

# Display the selective colorization effect image
axs[5].imshow(selective_colorization_effect_image)
axs[5].axis('off')
axs[5].set_title('Selective Colorization Effect Image')

# Paris, Banks of the Seine 1 (Alien invasion gif) (Online source image and self create)

from PIL import Image, ImageDraw, ImageFont

# Paths to the images
image_paths = [
    '/content/Paris, Banks of the Seine 1.jpg',
    '/content/For gif used 4.jpg',
    '/content/Paris, Banks of the Seine 1 Selective Colorization Effect Image.jpg'
]

# Load the images for the GIF
images = [Image.open(path) for path in image_paths]

# Define the text for each image
texts = ["Before alien invasion", "When alien invasion", "After alien invasion"]
font_size = 64
font = ImageFont.truetype("LiberationSans-Bold.ttf", font_size)  # Use a bold font for better visibility

# Create a GIF with the text displaying
frames = []
duration = 3000  #

# Generate the frames
for (image, text) in zip(images, texts):
    image = image.resize(images[0].size, Image.ANTIALIAS)
    draw = ImageDraw.Draw(image)
    text_width, text_height = draw.textsize(text, font=font)
    text_position = ((image.width - text_width) // 2, (image.height - text_height) // 2)
    draw.text(text_position, text, font=font, fill="red")
    frames.extend([image] * (duration // 100))

# Save the frames as a GIF
gif_path = 'Alien Invasion Text.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# Paris, Banks of the Seine 2

from PIL import Image, ImageFilter
import numpy as np
import matplotlib.pyplot as plt

# Load the image
original_image_path = '/content/Paris, Banks of the Seine 2.jpg'
original_image = Image.open(original_image_path)

# Function alien atmosphere effect
def alien_atmosphere(image):
    hsv_image = image.convert('HSV')
    data = np.array(hsv_image)
    data[..., 1] = data[..., 1] * 1.2
    data[..., 0] = (data[..., 0] + 85) % 255  #
    new_image = Image.fromarray(data, 'HSV')
    return new_image.convert('RGB')

# Funtion alien communication effect
def alien_communication(image):
    comm_image = image.copy()
    comm_image = comm_image.convert("RGB")
    pixels = comm_image.load()
    for i in range(comm_image.size[0]):
        for j in range(comm_image.size[1]):
            if i % 50 < 25:
                pixels[i, j] = (255 - pixels[i, j][0], 255 - pixels[i, j][1], 255 - pixels[i, j][2])
    return comm_image

communication_image = alien_communication(original_image)

# Edge detection effect
def edge_detection(image):
    return image.filter(ImageFilter.FIND_EDGES)

# Pixelation effect
def pixelate(image, pixel_size=10):
    small_image = image.resize(
        (image.width // pixel_size, image.height // pixel_size),
        resample=Image.NEAREST
    )
    return small_image.resize(image.size, Image.NEAREST)

# Apply the effects
alien_atmosphere_image = alien_atmosphere(original_image)
alien_communication_atmosphere_image = alien_communication(alien_atmosphere_image)
edge_detection_image = edge_detection(original_image)
pixelation_edge_image = pixelate(edge_detection_image)

# Save the glitched effect image
save_path = 'Paris, Banks of the Seine 2 Pixel Effect Image.jpg'
pixelation_edge_image.save(save_path)

# Display the images in the requested order
fig, axs = plt.subplots(1, 5, figsize=(30, 6))

# Display the original image
axs[0].imshow(original_image)
axs[0].axis('off')
axs[0].set_title('Original Image')

# Display the atmosphere effect image
axs[1].imshow(alien_atmosphere_image)
axs[1].axis('off')
axs[1].set_title('Atmosphere Effect Image')

# Display the cutting line effect image
axs[2].imshow(alien_communication_atmosphere_image)
axs[2].axis('off')
axs[2].set_title('Cutting Line Effect Image')

# Display the edge detection effect image
axs[3].imshow(edge_detection_image)
axs[3].axis('off')
axs[3].set_title('Edge Detection Effect Image')

# Display the pixel effect image
axs[4].imshow(pixelation_edge_image)
axs[4].axis('off')
axs[4].set_title('Pixel Effect Image')

plt.tight_layout()
plt.show()

# Paris, Banks of the Seine 2 (Aliens walking gif) (Self create)

from PIL import Image, ImageDraw

def draw_alien_figure(draw, top_left, width, height, color=(0, 255, 0)):
    # Define the body of the alien
    body_height = height // 2
    body_width = width
    antenna_width = body_width // 4
    antenna_height = height // 4

    # Draw the body of the alien
    body_top_left = (top_left[0], top_left[1] + antenna_height)
    body_bottom_right = (body_top_left[0] + body_width, body_top_left[1] + body_height)
    draw.rectangle([body_top_left, body_bottom_right], fill=color)

    # Draw the antennas
    antenna_left_top_left = (top_left[0] + body_width // 4, top_left[1])
    antenna_left_bottom_right = (antenna_left_top_left[0] + antenna_width, antenna_left_top_left[1] + antenna_height)
    draw.rectangle([antenna_left_top_left, antenna_left_bottom_right], fill=color)
    antenna_right_top_left = (top_left[0] + body_width - body_width // 4 - antenna_width, top_left[1])
    antenna_right_bottom_right = (antenna_right_top_left[0] + antenna_width, antenna_right_top_left[1] + antenna_height)
    draw.rectangle([antenna_right_top_left, antenna_right_bottom_right], fill=color)

    # Draw eyes
    eye_size = width // 10
    eye_left_x = top_left[0] + body_width // 3 - eye_size // 2
    eye_right_x = top_left[0] + body_width // 3 * 2 - eye_size // 2
    eye_y = top_left[1] + antenna_height + body_height // 3 - eye_size // 2
    draw.ellipse([eye_left_x, eye_y, eye_left_x + eye_size, eye_y + eye_size], fill="white")
    draw.ellipse([eye_right_x, eye_y, eye_right_x + eye_size, eye_y + eye_size], fill="white")

def create_walking_alien_animation(image_path, num_frames=30, num_aliens=3, alien_width=100, alien_height=100):
    # Load the  image
    bg_image = Image.open(image_path)
    width, height = bg_image.size

    # Define paths for each alien
    paths = [
        lambda f: (f * (width // num_frames), height - alien_height),
        lambda f: ((num_frames - f) * (width // num_frames), height - alien_height),
        lambda f: (width // 2 - alien_width // 2, height - alien_height)
    ]

    frames = []

    for frame_number in range(num_frames):
        frame = bg_image.copy()
        draw = ImageDraw.Draw(frame)
        for n in range(num_aliens):
            x, y = paths[n](frame_number)
            draw_alien_figure(draw, (x, y), alien_width, alien_height)

        frames.append(frame)

    return frames

# Generate the frames for the animation with walking aliens
frames = create_walking_alien_animation('/content/Paris, Banks of the Seine 2 Pixel Effect Image.jpg')

# Save the animation as a GIF
gif_path = 'Alien Walking.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

gif_path

# Paris, Banks of the Seine 3

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Define paths to the images
original_image_path = '/content/Paris, Banks of the Seine 3.jpg'
overlay_image_path = '/content/Overlay 18.jpg'

# Load the images
original_image = cv2.imread(original_image_path)
overlay_image = cv2.imread(overlay_image_path)

# Resize the overlay image to match the original image size
overlay_image = cv2.resize(overlay_image, (original_image.shape[1], original_image.shape[0]))

# Define the effect functions
def overlay_effect(background, overlay):
    return cv2.addWeighted(background, 0.5, overlay, 0.5, 0)

def alien_glow_effect(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    hsv[:, :, 1] = cv2.add(hsv[:, :, 1], 50)
    return cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

def ufo_spotlight_effect(image):
    overlay = np.zeros_like(image)
    rows, cols = image.shape[:2]
    center = (int(cols / 2), int(rows / 4))
    cv2.circle(overlay, center, 150, (255, 255, 255), -1)
    mask = cv2.GaussianBlur(overlay, (0, 0), 30)
    return cv2.addWeighted(image, 0.7, mask, 0.3, 0)

def emboss_effect(image):
    kernel = np.array([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]], dtype=np.float32)
    embossed = cv2.filter2D(image, -1, kernel) + 128
    return np.clip(embossed, 0, 255).astype(np.uint8)

# Apply the overlay effect to create
overlay_effect_image = overlay_effect(original_image, overlay_image)

# Apply the other effects
alien_glow_overlay_img = alien_glow_effect(overlay_effect_image)
ufo_spotlight_overlay_img = ufo_spotlight_effect(overlay_effect_image)
embossed_overlay_img = emboss_effect(overlay_effect_image)

# Display the images using Matplotlib
fig, axes = plt.subplots(1, 6, figsize=(20, 10))

# Display the original image
axes[0].imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
axes[0].axis('off')
axes[0].set_title('Original Image')

# Display the overlay image
axes[1].imshow(cv2.cvtColor(overlay_image, cv2.COLOR_BGR2RGB))
axes[1].axis('off')
axes[1].set_title('Overlay Image')

# Display the overlay effect image
axes[2].imshow(cv2.cvtColor(overlay_effect_image, cv2.COLOR_BGR2RGB))
axes[2].axis('off')
axes[2].set_title('Overlay Effect Image')

# Display the alien glow effect image
axes[3].imshow(cv2.cvtColor(alien_glow_overlay_img, cv2.COLOR_BGR2RGB))
axes[3].axis('off')
axes[3].set_title('Alien Glow on Overlay Effect')

# Display the UFO spotlight effect image
axes[4].imshow(cv2.cvtColor(ufo_spotlight_overlay_img, cv2.COLOR_BGR2RGB))
axes[4].axis('off')
axes[4].set_title('UFO Spotlight on Overlay Effect')

# Display the embossed effect image
axes[5].imshow(cv2.cvtColor(embossed_overlay_img, cv2.COLOR_BGR2RGB))
axes[5].axis('off')
axes[5].set_title('Embossed on Overlay Effect')

plt.tight_layout()
plt.show()

"""# Part 2 Place 7"""

# Melaka and George Town 1

from PIL import Image, ImageEnhance, ImageOps, ImageFilter
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Melaka and George Town 1.jpg'
overlay_image_path = '/content/Overlay 15.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Ensure the overlay image is the same size as the original image
overlay_image = overlay_image.resize(original_image.size)

# Create an overlay effect image
overlay_effect_image = Image.blend(original_image, overlay_image, alpha=0.35)

# Color inversion effect e
color_inversion_effect_image = ImageOps.invert(overlay_effect_image)

# Embossed effect
embossed_effect_image = overlay_effect_image.filter(ImageFilter.EMBOSS)

# Function to save the color inversion effect image
def save_color_inversion_effect(image, file_path):
    image.save(file_path)

# Define the path to save the inversion effect image
color_inversion_effect_save_path = 'Melaka and George Town 1 Color Inversion Effect Image.jpg'

# Call the function to save the image
save_color_inversion_effect(color_inversion_effect_image, color_inversion_effect_save_path)

# Display the original image, overlay image, overlay effect image,
# color inversion effect image, and embossed effect image
fig, axs = plt.subplots(1, 5, figsize=(24, 12))

# Display the original image
axs[0].imshow(original_image)
axs[0].axis('off')
axs[0].set_title('Original Image')

# Display the overlay image
axs[1].imshow(overlay_image)
axs[1].axis('off')
axs[1].set_title('Overlay Image')

# Display the clearer overlay effect image
axs[2].imshow(overlay_effect_image)
axs[2].axis('off')
axs[2].set_title('Clear Overlay Effect Image')

# Display the color inversion effect image
axs[3].imshow(color_inversion_effect_image)
axs[3].axis('off')
axs[3].set_title('Color Inversion Effect Image')

# Display the embossed effect image
axs[4].imshow(embossed_effect_image)
axs[4].axis('off')
axs[4].set_title('Embossed Effect Image')

plt.tight_layout()
plt.show()

# Melaka and George Town 1 (Thunderstorm gif) (Self create)

from PIL import Image, ImageDraw
import numpy as np

# Function lightning bolt effect
def draw_lightning(draw, img_size):
    num_segments = np.random.randint(4, 10)
    start = (np.random.randint(0, img_size[0]), 0)
    end = (np.random.randint(0, img_size[0]), img_size[1])
    segments = [start]

    for i in range(1, num_segments):
        seg_x = np.random.randint(segments[i-1][0] - 30, segments[i-1][0] + 30)
        seg_y = int(segments[i-1][1] + (end[1] / num_segments))
        segments.append((seg_x, seg_y))
    segments.append(end)

    for i in range(1, len(segments)):
        brightness = np.random.randint(200, 255)
        draw.line([segments[i-1], segments[i]], fill=(brightness, brightness, brightness), width=2)

# Load the background image
background_path = '/content/Melaka and George Town 1 Color Inversion Effect Image.jpg'  # Replace with your path to the image
background = Image.open(background_path)

# Create frames for the thunderstorm effect
frames = []
for _ in range(30):
    frame = background.copy()
    draw = ImageDraw.Draw(frame)
    if np.random.random() > 0.5:
        draw_lightning(draw, background.size)
    frames.append(frame)

# Save the frames as a GIF
gif_path = 'Thunderstorm.gif'  # Replace with your desired save path
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# Melaka and George Town 2

from PIL import Image, ImageDraw
import numpy as np
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Melaka and George Town 2.jpg'
overlay_image_path = '/content/Overlay 16.jpg'
original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path)

# Resize the overlay to match the original image
overlay_image = overlay_image.resize(original_image.size)

# Create overlay effect image
overlay_effect_image = Image.blend(original_image, overlay_image, alpha=0.5)

# Scanline effect on overlay effect image
def scanline_effect(image, line_density=5, line_opacity=50):
    scanline_image = image.copy()
    draw = ImageDraw.Draw(scanline_image)
    for y in range(0, scanline_image.height, line_density):
        draw.line([(0, y), (scanline_image.width, y)], fill=(255, 255, 255, line_opacity), width=1)
    return scanline_image

scanline_effect_image = scanline_effect(overlay_effect_image)

# Space warp effect
def space_warp_effect(image):
    image_array = np.array(image)
    for i in range(image_array.shape[1]):
        image_array[:, i] = np.roll(image_array[:, i], int(20.0 * np.sin(2.0 * np.pi * i / 30.0)))
    return Image.fromarray(image_array)

space_warp_effect_image = space_warp_effect(scanline_effect_image)

# Save the space warp effect image
space_warp_effect_image_path = 'Melaka and George Town 2 Space Warp Effect Image.jpg'
space_warp_effect_image.save(space_warp_effect_image_path)

# Display the images
fig, axs = plt.subplots(1, 5, figsize=(24, 12))

# Original image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay image
axs[1].imshow(overlay_image)
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Overlay effect image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Scanline effect image
axs[3].imshow(scanline_effect_image)
axs[3].set_title('Scanline Effect Image')
axs[3].axis('off')

# Space warp effect image
axs[4].imshow(space_warp_effect_image)
axs[4].set_title('Space Warp Effect Image')
axs[4].axis('off')

plt.tight_layout()
plt.show()

# Melaka and George Town 2 (Teleportation gif) (Self create)

from PIL import Image, ImageDraw, ImageEnhance

def draw_teleportation(draw, center, max_radius, frame_number, total_frames):
    # Create a grey teleportation effect
    progress = frame_number / total_frames
    num_circles = 10
    for i in range(num_circles):
        radius = (progress * max_radius * (i / num_circles)) % max_radius
        opacity = int((1 - (radius / max_radius)) * 255)
        grey_value = 128
        color = (grey_value, grey_value, grey_value, opacity)
        draw.ellipse([center[0] - radius, center[1] - radius, center[0] + radius, center[1] + radius],
                     outline=color, width=3)

# Load the image
background_path = '/content/Melaka and George Town 2 Space Warp Effect Image.jpg'
background = Image.open(background_path)

# Parameters for the teleportation effect
n_frames = 40
max_radius = min(background.size) // 2

# Create the frames for the GIF
frames = []
for current_frame in range(n_frames):
    frame = Image.new("RGBA", background.size)
    frame.paste(background, (0, 0))
    draw = ImageDraw.Draw(frame)

    draw_teleportation(draw, (background.width // 2, background.height // 2),
                       max_radius, current_frame, n_frames)

    enhancer = ImageEnhance.Brightness(frame)
    frame_enhanced = enhancer.enhance(1.2)
    frame_rgb = frame_enhanced.convert('RGB')
    frames.append(frame_rgb)

# Save the frames as a GIF
gif_path = 'Teleportation.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# Melaka and George Town 3

from PIL import Image, ImageDraw, ImageFilter, ImageOps
import matplotlib.pyplot as plt

# Load the image
original_image_path = '/content/Melaka and George Town 3.jpg'
original_image = Image.open(original_image_path)

# Alien Atmosphere Effect
def alien_atmosphere_effect(image):
    r, g, b = image.split()
    g = g.point(lambda i: i * 1.5)
    return Image.merge('RGB', (r, g, b))

# Alien Tech Overlay Effect
def alien_tech_overlay_effect(image):
    tech_overlay = Image.new('RGB', image.size, color='black')
    draw = ImageDraw.Draw(tech_overlay)
    for i in range(0, tech_overlay.width, 20):
        for j in range(0, tech_overlay.height, 20):
            draw.rectangle([(i, j), (i + 10, j + 10)], outline=(0, 255, 0), width=1)
    return Image.blend(image, tech_overlay, alpha=0.15)

# Alien Signal Interface Effect
def alien_signal_interface_effect(image):
    interface_image = image.copy()
    draw = ImageDraw.Draw(interface_image)
    for i in range(0, interface_image.width, 30):
        draw.line([(i, 0), (i, interface_image.height)], fill=(255, 0, 0), width=1)
    for j in range(0, interface_image.height, 30):
        draw.line([(0, j), (interface_image.width, j)], fill=(0, 255, 0), width=1)
    return interface_image.filter(ImageFilter.CONTOUR)

# Alien Hue Shift Effect
def alien_hue_shift_effect(image):
    return ImageOps.colorize(image.convert('L'), 'black', 'purple')

# Apply the effects in sequence
alien_atmosphere_image = alien_atmosphere_effect(original_image)
alien_tech_overlay_image = alien_tech_overlay_effect(alien_atmosphere_image)
alien_signal_interface_image = alien_signal_interface_effect(alien_tech_overlay_image)
alien_hue_shift_image = alien_hue_shift_effect(alien_signal_interface_image)

# Display the images with effects
fig, axs = plt.subplots(1, 5, figsize=(25, 5))

# Save the glitched effect image
save_path = 'Melaka and George Town 3 Hue Shift Effect Image.jpg'  # Specify your save path
alien_hue_shift_image.save(save_path)


# Original image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Alien Atmosphere effect image
axs[1].imshow(alien_atmosphere_image)
axs[1].set_title('Atmosphere Effect Image')
axs[1].axis('off')

# Alien Tech Overlay effect image
axs[2].imshow(alien_tech_overlay_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Alien Signal Interface effect image
axs[3].imshow(alien_signal_interface_image)
axs[3].set_title('Signal Interface Effect Image')
axs[3].axis('off')

# Alien Hue Shift effect image
axs[4].imshow(alien_hue_shift_image)
axs[4].set_title('Hue Shift Effect Image')
axs[4].axis('off')

plt.tight_layout()
plt.show()

# Melaka and George Town 3 (Signal lost) (Self create)

from PIL import Image, ImageDraw, ImageFilter
import numpy as np

# Function corruption effect
def create_corruption_effect(draw, img_size, max_offset, frame_number):
    for i in range(0, img_size[1], 10):
        line_width = np.random.randint(1, max_offset)
        offset = np.random.randint(-max_offset, max_offset)
        draw.rectangle([0, i, img_size[0], i + line_width], fill=(0, 0, 0))
        draw.line([0, i, img_size[0], i + line_width], fill=(0, 255, 0), width=1)

# Load the background image for the corruption effect
background_path = '/content/Melaka and George Town 3 Hue Shift Effect Image.jpg'
background = Image.open(background_path)

# Parameters for the corruption effect
n_frames = 30

# Create the frames for the GIF
frames = []
for current_frame in range(n_frames):
    frame = background.copy()
    draw = ImageDraw.Draw(frame)
    create_corruption_effect(draw, background.size, 5, current_frame)
    frame = frame.filter(ImageFilter.GaussianBlur(radius=1))
    frames.append(frame)

# Save the frames as a GIF
gif_path = 'Signal Lost.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

"""# Part 3"""

# Sansa, Buddhist Mountain Monasteries in Korea

from PIL import Image, ImageChops, ImageDraw, ImageEnhance, ImageOps
import numpy as np
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Sansa, Buddhist Mountain Monasteries in Korea 1.jpg'
overlay_image_path = '/content/Overlay 20.jpg'
original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path).resize(original_image.size)

# Apply overlay effect
def apply_overlay_effect(base_image, overlay):
    return ImageChops.multiply(base_image, overlay)

# Apply desolate effect
def apply_desolate_effect(image):
    grayscale = ImageOps.grayscale(image)
    contrast = ImageEnhance.Contrast(grayscale).enhance(2)
    return contrast

# Apply energy disruption effect
def apply_energy_disruption_effect(image):
    src_array = np.array(image)
    for i in range(src_array.shape[0]):
        offset = int(20.0 * np.sin(i / 20.0))
        src_array[i] = np.roll(src_array[i], offset, axis=0)
    return Image.fromarray(src_array)

# Apply scan line effect
def apply_scan_line_effect(image, line_height=1, line_spacing=5):
    scan_image = image.copy()
    draw = ImageDraw.Draw(scan_image)
    for y in range(0, scan_image.height, line_spacing):
        draw.line([(0, y), (scan_image.width, y)], fill='black', width=line_height)
    return scan_image

# Create effects
overlay_effect_image = apply_overlay_effect(original_image, overlay_image)
desolate_effect_image = apply_desolate_effect(overlay_effect_image)
energy_disruption_effect_image = apply_energy_disruption_effect(desolate_effect_image)
scan_line_effect_image = apply_scan_line_effect(energy_disruption_effect_image)

# Display the images in a row using matplotlib
fig, axs = plt.subplots(1, 6, figsize=(20, 3))

# Original Image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay Image
axs[1].imshow(overlay_image)
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Overlay Effect Image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Desolate Effect Image
axs[3].imshow(desolate_effect_image, cmap='gray')
axs[3].set_title('Desolate Effect Image')
axs[3].axis('off')

# Energy Disruption Effect Image
axs[4].imshow(energy_disruption_effect_image)
axs[4].set_title('Energy Disruption Effect Image')
axs[4].axis('off')

# Scan Line Effect Image
axs[5].imshow(scan_line_effect_image)
axs[5].set_title('Scan Line Effect Image')
axs[5].axis('off')

plt.tight_layout()
plt.show()

# Archaeological Site of Cyrene

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Load the images
original_image_path = '/content/Archaeological Site of Cyrene 3.jpg'
overlay_image_path = '/content/Overlay 22.jpg'

original_image = Image.open(original_image_path)
overlay_image = Image.open(overlay_image_path).resize(original_image.size)

# Function to apply overlay effect
def apply_overlay_effect(base_image, overlay):
    return ImageChops.multiply(base_image, overlay)

# Create the overlay effect image
overlay_effect_image = apply_overlay_effect(original_image, overlay_image)

# Save the overlay effect image
save_path = 'Archaeological Site of Cyrene 3 Overlay Effect Image.jpg'
overlay_effect_image.save(save_path)

# Display the images using matplotlib
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Original Image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay Image
axs[1].imshow(overlay_image)
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Overlay Effect Image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

plt.tight_layout()
plt.show()

# Archaeological Site of Cyrene (Rock falling gif) (Self create)

from PIL import Image, ImageDraw, ImageFilter
import random

# Load the image
base_image_path = '/content/Archaeological Site of Cyrene 3 Overlay Effect Image.jpg'
base_image = Image.open(base_image_path).convert("RGBA")

# Define function falling stones
def create_crumbling_effect(base_image, num_frames=20, num_stones_per_frame=2, stone_size_range=(100, 150)):
    frames = []
    width, height = base_image.size

    for frame_number in range(num_frames):
        frame = base_image.copy()
        draw = ImageDraw.Draw(frame)
        for _ in range(num_stones_per_frame):
            stone_x = random.randint(0, width)
            stone_y = frame_number * (height // num_frames)
            stone_size = random.randint(*stone_size_range)
            points = []
            for _ in range(random.randint(5, 7)):
                random_point = (stone_x + random.randint(-stone_size // 2, stone_size // 2),
                                stone_y + random.randint(-stone_size // 2, stone_size // 2))
                points.append(random_point)
            draw.polygon(points, fill='grey')
        frame = frame.filter(ImageFilter.GaussianBlur(radius=2))
        frames.append(frame)
    return frames

# Create the sequence of frames with the crumbling effect
frames = create_crumbling_effect(base_image)

# Save the images as a GIF
gif_path = 'Rocks Falling.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=500, loop=0)

# Melaka and George Town

from PIL import Image, ImageChops, ImageOps
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.cm as cm

# Define overlay effect
def apply_overlay_effect(base_image, overlay):
    return ImageChops.multiply(base_image, overlay)

# Define invert colors
def apply_color_inversion(image):
    return ImageOps.invert(image)

# Define simulate an infrared effect
def apply_infrared_effect(image):
    r, g, b = image.split()
    r = ImageOps.invert(r)
    return Image.merge('RGB', (r, g, b))

# Load the original and overlay images
original_image = Image.open('/content/Melaka and George Town 3.jpg')
overlay_image = Image.open('/content/Overlay 23.jpg').resize(original_image.size)

# Apply overlay effect
overlay_effect_image = apply_overlay_effect(original_image, overlay_image)

# Apply color inversion effect
color_inversion_effect_image = apply_color_inversion(overlay_effect_image)

# Apply infrared effect
infrared_effect_image = apply_infrared_effect(overlay_effect_image)

# Convert images to numpy arrays for applying colormaps
overlay_effect_array = np.array(overlay_effect_image.convert('L'))

# Apply COLORMAP_RAINBOW effect
rainbow_effect_image = Image.fromarray((cm.rainbow(overlay_effect_array / 255.0)[:, :, :3] * 255).astype(np.uint8))

# Apply COLORMAP_OCEAN effect
ocean_effect_image = Image.fromarray((cm.ocean(overlay_effect_array / 255.0)[:, :, :3] * 255).astype(np.uint8))

# Display the images using matplotlib
fig, axs = plt.subplots(1, 7, figsize=(35, 5))

# Original Image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay Image
axs[1].imshow(overlay_image)
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Overlay Effect Image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Color Inversion Effect Image
axs[3].imshow(color_inversion_effect_image)
axs[3].set_title('Color Inversion Effect Image')
axs[3].axis('off')

# Infrared Effect Image
axs[4].imshow(infrared_effect_image)
axs[4].set_title('Infrared Effect Image')
axs[4].axis('off')

# COLORMAP_RAINBOW Effect Image
axs[5].imshow(rainbow_effect_image)
axs[5].set_title('Colormap Randow Effect')
axs[5].axis('off')

# COLORMAP_OCEAN Effect Image
axs[6].imshow(ocean_effect_image)
axs[6].set_title('Colormap Ocean Effect')
axs[6].axis('off')

plt.tight_layout()
plt.show()

# Monasteries of Haghpat and Sanahin

from PIL import Image, ImageFilter, ImageEnhance
import matplotlib.pyplot as plt

# Function a gradual bokeh effect from left to right
def apply_gradual_bokeh(image, clear_fraction):
    width, height = image.size
    blurred_image = image.filter(ImageFilter.GaussianBlur(radius=15))  # Bokeh effect
    mask = Image.new("L", (width, height), 255)
    mask.paste(0, (0, 0, int(width * clear_fraction), height))
    return Image.composite(blurred_image, image, mask)

# Function contrast effect
def apply_contrast(image, factor=2):
    enhancer = ImageEnhance.Contrast(image)
    return enhancer.enhance(factor)

# Load the original image
original_image_path = '/content/Monasteries of Haghpat and Sanahin 3.jpg'
original_image = Image.open(original_image_path)

# Apply contrast effect
contrast_image = apply_contrast(original_image)

# Apply bokeh effect
bokeh_images = [apply_gradual_bokeh(contrast_image, fraction) for fraction in [0.75, 0.50, 0.25, 0.0]]

# Save the high dynamic range effect image
save_path = 'Monasteries of Haghpat and Sanahin Contrast Effect Image.jpg'
contrast_image.save(save_path)

# Display the images
fig, axs = plt.subplots(1, 6, figsize=(30, 5))

# Original image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Contrast image
axs[1].imshow(contrast_image)
axs[1].set_title('Contrast Effect Image')
axs[1].axis('off')

# Bokeh effect images from full to 1/4
for i, img in enumerate(bokeh_images, start=2):
    axs[i].imshow(img)
    axs[i].set_title(f'{i-1}/4 Bokeh Effect Image')
    axs[i].axis('off')

plt.tight_layout()
plt.show()

# Monasteries of Haghpat and Sanahin (Butterflies gif) (Self create)

from PIL import Image, ImageDraw, ImagePath
import random

# Load the image
bg_image_path = '/content/Monasteries of Haghpat and Sanahin Contrast Effect Image.jpg'
bg_image = Image.open(bg_image_path).convert("RGBA")

# Define the number of frames and butterflies
num_frames = 60
num_butterflies = 3

# Function draw a butterfly shape
def draw_butterfly(draw, position, size, colors):
    wing_size = (size[0] // 2, size[1] // 2)
    draw.ellipse([position[0], position[1], position[0] + wing_size[0], position[1] + wing_size[1]], fill=colors[0])
    draw.ellipse([position[0] + wing_size[0], position[1], position[0] + size[0], position[1] + wing_size[1]], fill=colors[1])
    draw.ellipse([position[0], position[1] + wing_size[1], position[0] + wing_size[0], position[1] + size[1]], fill=colors[2])
    draw.ellipse([position[0] + wing_size[0], position[1] + wing_size[1], position[0] + size[0], position[1] + size[1]], fill=colors[3])

# Function to create a frame with butterflies
def create_frame(bg_image, num_butterflies, butterfly_size):
    frame = bg_image.copy()
    draw = ImageDraw.Draw(frame, 'RGBA')

    # Draw each butterfly in a random position and with random colors
    for _ in range(num_butterflies):
        position = (random.randint(0, bg_image.width - butterfly_size[0]), random.randint(0, bg_image.height - butterfly_size[1]))
        colors = [tuple(random.choices(range(256), k=3)) for _ in range(4)]
        draw_butterfly(draw, position, butterfly_size, colors)

    return frame

# Create the frames for the GIF
frames = [create_frame(bg_image, num_butterflies, (50, 35)) for _ in range(num_frames)]

# Save the frames as a GIF
gif_path = 'Butterflies.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# Memphis and its Necropolis

from PIL import Image, ImageFilter, ImageEnhance
import matplotlib.pyplot as plt

# Function overlay image
def apply_overlay(original, overlay, transparency):
    overlay = overlay.resize(original.size)
    overlay.putalpha(transparency)
    return Image.alpha_composite(original.convert("RGBA"), overlay).convert('RGB')

# Function tone mapping effect
def apply_tone_mapping(image):
    enhancer = ImageEnhance.Contrast(image)
    return enhancer.enhance(2.0)

# Function bokeh effect
def apply_bokeh_effect(image):
    return image.filter(ImageFilter.GaussianBlur(radius=15))

# Load images
original_img_path = '/content/Memphis and its Necropolis 2.jpg'
overlay1_img_path = '/content/Overlay 26.jpg'
overlay2_img_path = '/content/Overlay 27.jpg'

original = Image.open(original_img_path)
overlay1 = Image.open(overlay1_img_path)
overlay2 = Image.open(overlay2_img_path)

# Apply overlay effects with different transparencies
overlay_effect_50 = apply_overlay(original, overlay1, 128)
overlay_effect_30 = apply_overlay(original, overlay2, 128)

# Combine both overlay effects ge
overlay_effect_combined = Image.blend(overlay_effect_50, overlay_effect_30, alpha=0.3)

# Apply tone mapping and bokeh effects
tone_mapping_effect = apply_tone_mapping(overlay_effect_combined)
bokeh_effect = apply_bokeh_effect(overlay_effect_combined)

# Display the images
fig, axs = plt.subplots(1, 6, figsize=(30, 5))

axs[0].imshow(original)
axs[0].set_title('Original Image')
axs[0].axis('off')

axs[1].imshow(overlay1)
axs[1].set_title('Overlay Image 1')
axs[1].axis('off')

axs[2].imshow(overlay_effect_50)
axs[2].set_title('Overlay Effect 1')
axs[2].axis('off')

axs[3].imshow(overlay2)
axs[3].set_title('Overlay Image 2')
axs[3].axis('off')

axs[4].imshow(overlay_effect_30)
axs[4].set_title('Overlay Effect 2')
axs[4].axis('off')

axs[5].imshow(tone_mapping_effect)
axs[5].set_title('Tone Mapping Effect')
axs[5].axis('off')

plt.tight_layout()
plt.show()

# Paris, Banks of the Seine

from PIL import Image, ImageEnhance, ImageChops, ImageFilter, ImageDraw, ImageOps
import matplotlib.pyplot as plt

# Function overlay effect
def apply_overlay(base, overlay):
    overlay_with_transparency = overlay.copy()
    overlay_with_transparency.putalpha(128)
    return Image.alpha_composite(base.convert('RGBA'), overlay_with_transparency).convert('RGB')

# Function contrast effect
def apply_contrast_effect(image, factor=2.0):
    enhancer = ImageEnhance.Contrast(image)
    return enhancer.enhance(factor)

# Function Lomography effect
def apply_lomography_effect(image):
    color_enhancer = ImageEnhance.Color(image)
    lomo_image = color_enhancer.enhance(1.5)
    vignette = Image.new("L", image.size, "black")
    draw = ImageDraw.Draw(vignette)
    x, y = image.size[0] // 2, image.size[1] // 2
    radius = min(image.size) // 2
    draw.ellipse((x - radius, y - radius, x + radius, y + radius), fill="white")
    vignette = vignette.filter(ImageFilter.GaussianBlur(radius // 2))
    lomo_image.paste(ImageOps.colorize(vignette, "black", "white"), (0, 0), vignette)
    return lomo_image

# Function to apply High Dynamic Range (HDR) effect
def apply_hdr_effect(image):
    return image.filter(ImageFilter.UnsharpMask(radius=2, percent=150, threshold=3))

# Load the images
original_image_path = '/content/Paris, Banks of the Seine 1.jpg'
overlay_image_path = '/content/Overlay 24.jpg'
original_image = Image.open(original_image_path).convert('RGBA')
overlay_image = Image.open(overlay_image_path).resize(original_image.size).convert('RGBA')

# Apply the effects
contrast_effect_image = apply_contrast_effect(original_image.convert('RGB'))
overlay_effect_image = apply_overlay(original_image, overlay_image).convert('RGB')
lomography_effect_image = apply_lomography_effect(overlay_effect_image)
hdr_effect_image = apply_hdr_effect(overlay_effect_image)

# Save the high dynamic range effect image
save_path = 'Paris, Banks of the Seine High Dynamic Range Effect Image.jpg'
hdr_effect_image.save(save_path)

# Display the images
fig, axs = plt.subplots(1, 6, figsize=(25, 5))

# Original Image
axs[0].imshow(original_image.convert('RGB'))
axs[0].set_title('Original Image')
axs[0].axis('off')

# Contrast Effect Image
axs[1].imshow(contrast_effect_image)
axs[1].set_title('Contrast Effect Image')
axs[1].axis('off')

# Overlay Image'
axs[2].imshow(overlay_image.convert('RGB'))
axs[2].set_title('Overlay Image')
axs[2].axis('off')

# Overlay Image'
axs[3].imshow(overlay_effect_image)
axs[3].set_title('Overlay Image')
axs[3].axis('off')

#Lomography Effect Image
axs[4].imshow(lomography_effect_image)
axs[4].set_title('Lomography Effect Image')
axs[4].axis('off')

#High Dynamic Range Effect Image
axs[5].imshow(hdr_effect_image)
axs[5].set_title('High Dynamic Range Effect Image')
axs[5].axis('off')

plt.tight_layout()
plt.show()

# Paris, Banks of the Seine (Drawing gif) (Self create)

from PIL import Image, ImageDraw, ImageSequence, ImageChops

# Load the image
image_path = "/content/Paris, Banks of the Seine High Dynamic Range Effect Image.jpg"
image = Image.open(image_path)

# Parameters for the animation
num_frames = 60
hand_width, hand_height = 20, 40

# Coordinates for the hand
hand_path = [
    (330, 450), (330, 400), (330, 350), (320, 300), (310, 250),
    (300, 200), (290, 150), (280, 100), (270, 50), (260, 30),
    (250, 60), (240, 100), (230, 150), (220, 200), (210, 250),
    (200, 300), (190, 350), (190, 400), (190, 450)
]

# Function to draw a simple hand shape
def draw_hand(draw, position):
    draw.rectangle([position, (position[0] + hand_width, position[1] + hand_height)], fill="brown")

# Function to draw lines following the hand path
def draw_lines(draw, start_index, end_index):
    if end_index > start_index:
        draw.line(hand_path[start_index:end_index + 1], fill="black", width=2)

frames = []
drawn_tower = Image.new('RGBA', image.size, (255, 255, 255, 0))

# Create each frame with the hand moving
for frame_index in range(num_frames):
    path_index = int((frame_index / num_frames) * (len(hand_path) - 1))
    frame = image.copy()
    draw = ImageDraw.Draw(frame)
    draw_tower = ImageDraw.Draw(drawn_tower)
    hand_position = hand_path[path_index]
    draw_hand(draw, hand_position)
    draw_lines(draw_tower, 0, path_index)
    frame = Image.alpha_composite(frame.convert("RGBA"), drawn_tower)
    frames.append(frame)

# Save the frames as a GIF
gif_path = "Drawing.gif"
frames[0].save(gif_path,
               save_all=True,
               append_images=frames[1:],
               loop=0,
               duration=100,
               optimize=False)

# Rapa Nui National Park

from PIL import Image, ImageFilter, ImageChops, ImageOps
import numpy as np
import matplotlib.pyplot as plt
import cv2

# Load the images
original_image = Image.open('/content/Rapa Nui National Park 1.jpg')
overlay_image = Image.open('/content/Overlay 25.jpg').resize(original_image.size)

# Apply overlay
overlay_image.putalpha(128)
overlay_effect_image = Image.alpha_composite(original_image.convert('RGBA'), overlay_image).convert('RGB')

# Sobel filter effect
def apply_sobel_filter(image):
    gray_image = ImageOps.grayscale(image)
    sobel_image = gray_image.filter(ImageFilter.FIND_EDGES)
    return sobel_image

# Prewitt filter effect
def apply_prewitt_filter(image):
    gray_image = ImageOps.grayscale(image)
    kernel = ImageFilter.Kernel((3, 3), [-1, 0, 1, -1, 0, 1, -1, 0, 1], 1, 0)
    prewitt_image = gray_image.filter(kernel)
    return prewitt_image

# Canny edge detection
def apply_canny_edge_detection(image):
    image_array = np.array(image.convert('L'))
    edges = cv2.Canny(image_array, threshold1=100, threshold2=200)
    return Image.fromarray(edges)

# Invert colors for sketch effect
def invert_colors(image):
    # Invert image colors
    inverted_image = ImageOps.invert(image)
    return inverted_image

# Apply the filter effects using the overlay effect image
sobel_filter_effect_image = apply_sobel_filter(overlay_effect_image)
prewitt_filter_effect_image = apply_prewitt_filter(overlay_effect_image)
canny_edge_detection_image = apply_canny_edge_detection(overlay_effect_image)
sketch_effect_image = invert_colors(canny_edge_detection_image)

# Save the high dynamic range effect image
save_path = 'Rapa Nui National Park Sketch Effect Image.jpg'
sketch_effect_image.save(save_path)

# Display the images
fig, axs = plt.subplots(1, 6, figsize=(28, 5))

# Original Image
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')

# Overlay Image
axs[1].imshow(overlay_image.convert('RGB'))
axs[1].set_title('Overlay Image')
axs[1].axis('off')

# Overlay Effect Image
axs[2].imshow(overlay_effect_image)
axs[2].set_title('Overlay Effect Image')
axs[2].axis('off')

# Sobel Filter Effect
axs[3].imshow(sobel_filter_effect_image, cmap='gray')
axs[3].set_title('Sobel Filter Effect')
axs[3].axis('off')

# Prewitt Filter Effect
axs[4].imshow(prewitt_filter_effect_image, cmap='gray')
axs[4].set_title('Prewitt Filter Effect')
axs[4].axis('off')

# Sketch Effect Image
axs[5].imshow(sketch_effect_image, cmap='gray')
axs[5].set_title('Sketch Effect Image')
axs[5].axis('off')

plt.tight_layout()
plt.show()

# Rapa Nui National Park (Hand drawing gif) (Online source image)

from PIL import Image
import numpy as np

# Load the images
bg_image_path = '/content/Rapa Nui National Park Sketch Effect Image.jpg'
hand_image_path = '/content/For gif used 7.jpg'
bg_image = Image.open(bg_image_path).convert("RGBA")
hand_image = Image.open(hand_image_path).convert("RGBA")

# Set the parameters for the animation
num_frames = 40
draw_speed = bg_image.width / num_frames

# Create a list to store the frames
frames = []

# Generate each frame in the animation
for frame_number in range(num_frames):
    frame = bg_image.copy()
    hand_x = int((bg_image.width - hand_image.width) / 2 * (1 + np.sin(frame_number / num_frames * 2 * np.pi)))
    hand_y = bg_image.height // 2 - hand_image.height // 2
    frame.paste(hand_image, (hand_x, hand_y), hand_image)
    frames.append(frame)

# Save the images as a GIF
gif_path = 'Hand Drawing.gif'
frames[0].save(gif_path, save_all=True, append_images=frames[1:], optimize=False, duration=100, loop=0)

# The End (End of the story) (Self create)

from PIL import Image

# Define a function to create a transition between two images
def create_transition(image1, image2, steps=5):
    transition_images = []
    for i in range(steps + 1):
        blend = Image.blend(image1, image2, i / steps)
        transition_images.append(blend)
    return transition_images

# List of image paths
image_paths = [
    '/content/Melaka and George Town 1.jpg',
    '/content/Melaka and George Town 2.jpg',
    '/content/Melaka and George Town 3.jpg',
    '/content/Memphis and its Necropolis 1.jpg',
    '/content/Memphis and its Necropolis 2.jpg',
    '/content/Memphis and its Necropolis 3.jpg',
    '/content/Monasteries of Haghpat and Sanahin 1.jpg',
    '/content/Monasteries of Haghpat and Sanahin 2.jpg',
    '/content/Monasteries of Haghpat and Sanahin 3.jpg',
    '/content/Paris, Banks of the Seine 1.jpg',
    '/content/Paris, Banks of the Seine 2.jpg',
    '/content/Paris, Banks of the Seine 3.jpg',
    '/content/Rapa Nui National Park 1.jpg',
    '/content/Rapa Nui National Park 2.jpg',
    '/content/Rapa Nui National Park 3.jpg',
    '/content/Rapa Nui National Park 4.jpg',
    '/content/Sansa, Buddhist Mountain Monasteries in Korea 1.jpg',
    '/content/Sansa, Buddhist Mountain Monasteries in Korea 2.jpg',
    '/content/Sansa, Buddhist Mountain Monasteries in Korea 3.jpg',
    '/content/For gif used 6.jpg'
]

# Open all the images and convert them to RGBA
images = [Image.open(x).convert("RGBA") for x in image_paths]

# Resize images to the minimum width and height
min_width = min(image.size[0] for image in images)
min_height = min(image.size[1] for image in images)
images = [image.resize((min_width, min_height), Image.ANTIALIAS) for image in images]

# Create a list to hold all the final images to include in the GIF
final_images = []

# Generate transition images between each pair of images
for i in range(len(images) - 1):
    final_images.append(images[i])
    final_images.extend(create_transition(images[i], images[i + 1]))

# Append the last image and set its display time to 3 seconds
final_images.append(images[-1])

# Set duration for all images except the last one to 500ms (0.5s)
durations = [100] * (len(final_images) - 1)
durations.append(3000)

# Save the images as a GIF
gif_path_with_last_longer = 'End Of Story.gif'
final_images[0].save(gif_path_with_last_longer, save_all=True, append_images=final_images[1:], optimize=False, duration=durations, loop=0)

gif_path_with_last_longer